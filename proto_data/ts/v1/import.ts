// @generated by protobuf-ts 2.9.4 with parameter long_type_number,generate_dependencies,ts_nocheck,output_typescript
// @generated from protobuf file "v1/import.proto" (syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from '@protobuf-ts/runtime-rpc';
import type { BinaryWriteOptions } from '@protobuf-ts/runtime';
import type { IBinaryWriter } from '@protobuf-ts/runtime';
import { WireType } from '@protobuf-ts/runtime';
import type { BinaryReadOptions } from '@protobuf-ts/runtime';
import type { IBinaryReader } from '@protobuf-ts/runtime';
import { UnknownFieldHandler } from '@protobuf-ts/runtime';
import type { PartialMessage } from '@protobuf-ts/runtime';
import { reflectionMergePartial } from '@protobuf-ts/runtime';
import { MessageType } from '@protobuf-ts/runtime';
/**
 * @generated from protobuf message ImportFiles
 */
export interface ImportFiles {
    /**
     * @generated from protobuf field: repeated string file_path = 1;
     */
    filePath: string[];
}
/**
 * @generated from protobuf message ImportResult
 */
export interface ImportResult {
    /**
     * @generated from protobuf field: map<string, ImportResult.Column> columns = 1;
     */
    columns: {
        [key: string]: ImportResult_Column;
    }; // key: column_id, value: ImportColumn
    /**
     * @generated from protobuf field: repeated ImportResult.Row rows = 2;
     */
    rows: ImportResult_Row[];
    /**
     * @generated from protobuf field: ImportResult.Stats stats = 3;
     */
    stats?: ImportResult_Stats;
}
/**
 * @generated from protobuf message ImportResult.Column
 */
export interface ImportResult_Column {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: int64 width = 3;
     */
    width: number;
    /**
     * @generated from protobuf field: bool required = 4;
     */
    required: boolean; // default is false
    /**
     * @generated from protobuf field: bool sticky = 5;
     */
    sticky: boolean; // default is false
    /**
     * @generated from protobuf field: string sample_value = 6;
     */
    sampleValue: string;
    /**
     * @generated from protobuf field: int64 position = 7;
     */
    position: number;
}
/**
 * @generated from protobuf message ImportResult.Row
 */
export interface ImportResult_Row {
    /**
     * @generated from protobuf field: map<string, ImportResult.Row.Cell> cells = 1;
     */
    cells: {
        [key: string]: ImportResult_Row_Cell;
    }; // key: column_id, value: Cell
    /**
     * @generated from protobuf field: bool has_errors = 2;
     */
    hasErrors: boolean; // default is false
    /**
     * @generated from protobuf field: repeated ImportResult.Row.Error errors = 3;
     */
    errors: ImportResult_Row_Error[];
    /**
     * @generated from protobuf field: bool imported = 4;
     */
    imported: boolean; // default is false
    /**
     * @generated from protobuf field: repeated string data = 5;
     */
    data: string[]; // Assuming this holds list of strings. Update type if otherwise.
}
/**
 * @generated from protobuf message ImportResult.Row.Error
 */
export interface ImportResult_Row_Error {
    /**
     * @generated from protobuf field: string label = 1;
     */
    label: string;
    /**
     * @generated from protobuf field: string value = 2;
     */
    value: string;
    /**
     * @generated from protobuf field: string description = 3;
     */
    description: string;
}
/**
 * @generated from protobuf message ImportResult.Row.Cell
 */
export interface ImportResult_Row_Cell {
    /**
     * @generated from protobuf field: ImportResult.Row.Cell.Status status = 1;
     */
    status: ImportResult_Row_Cell_Status;
    /**
     * @generated from protobuf field: string value = 2;
     */
    value: string;
    /**
     * @generated from protobuf field: repeated ImportResult.Row.Error errors = 3;
     */
    errors: ImportResult_Row_Error[];
}
/**
 * @generated from protobuf enum ImportResult.Row.Cell.Status
 */
export enum ImportResult_Row_Cell_Status {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: SUCCESS = 1;
     */
    SUCCESS = 1,
    /**
     * @generated from protobuf enum value: ERROR = 2;
     */
    ERROR = 2
}
/**
 * @generated from protobuf message ImportResult.Stats
 */
export interface ImportResult_Stats {
    /**
     * @generated from protobuf field: int32 total_rows = 1;
     */
    totalRows: number;
    /**
     * @generated from protobuf field: int32 total_rows_valid = 2;
     */
    totalRowsValid: number;
    /**
     * @generated from protobuf field: int32 total_rows_invalid = 3;
     */
    totalRowsInvalid: number;
    /**
     * @generated from protobuf field: repeated ImportResult.Stats.Error rows_group_by_error = 4;
     */
    rowsGroupByError: ImportResult_Stats_Error[];
}
/**
 * @generated from protobuf message ImportResult.Stats.Error
 */
export interface ImportResult_Stats_Error {
    /**
     * @generated from protobuf field: string label = 1;
     */
    label: string;
    /**
     * @generated from protobuf field: string value = 2;
     */
    value: string;
    /**
     * @generated from protobuf field: string description = 3;
     */
    description: string;
    /**
     * @generated from protobuf field: int64 count = 4;
     */
    count: number;
}
/**
 * Get Import Config
 *
 * @generated from protobuf message GetImportConfigRequest
 */
export interface GetImportConfigRequest {}
/**
 * @generated from protobuf message GetImportConfigReply
 */
export interface GetImportConfigReply {
    /**
     * @generated from protobuf field: repeated GetImportConfigReply.Category categories = 1;
     */
    categories: GetImportConfigReply_Category[];
    /**
     * @generated from protobuf field: repeated GetImportConfigReply.Error errors = 2;
     */
    errors: GetImportConfigReply_Error[];
}
/**
 * @generated from protobuf message GetImportConfigReply.Category
 */
export interface GetImportConfigReply_Category {
    /**
     * @generated from protobuf field: string category_id = 1;
     */
    categoryId: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: string description = 3;
     */
    description: string;
    /**
     * @generated from protobuf field: repeated GetImportConfigReply.Category.Processor processors = 5;
     */
    processors: GetImportConfigReply_Category_Processor[];
}
/**
 * @generated from protobuf message GetImportConfigReply.Category.Processor
 */
export interface GetImportConfigReply_Category_Processor {
    /**
     * @generated from protobuf field: ProcessorID processor_id = 1;
     */
    processorId: ProcessorID;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: string description = 3;
     */
    description: string;
    /**
     * @generated from protobuf field: string sample_file_url = 4;
     */
    sampleFileUrl: string;
    /**
     * @generated from protobuf field: string icon = 5;
     */
    icon: string;
    /**
     * @generated from protobuf field: repeated GetImportConfigReply.Category.Processor.RequiredFile required_files = 6;
     */
    requiredFiles: GetImportConfigReply_Category_Processor_RequiredFile[];
}
/**
 * @generated from protobuf message GetImportConfigReply.Category.Processor.RequiredFile
 */
export interface GetImportConfigReply_Category_Processor_RequiredFile {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: repeated GetImportConfigReply.Category.Processor.RequiredFile.Link links = 3;
     */
    links: GetImportConfigReply_Category_Processor_RequiredFile_Link[];
}
/**
 * @generated from protobuf message GetImportConfigReply.Category.Processor.RequiredFile.Link
 */
export interface GetImportConfigReply_Category_Processor_RequiredFile_Link {
    /**
     * @generated from protobuf field: string label = 1;
     */
    label: string;
    /**
     * @generated from protobuf field: string hover = 2;
     */
    hover: string;
    /**
     * @generated from protobuf field: string url = 3;
     */
    url: string;
}
/**
 * @generated from protobuf message GetImportConfigReply.Error
 */
export interface GetImportConfigReply_Error {
    /**
     * @generated from protobuf field: string label = 1;
     */
    label: string;
    /**
     * @generated from protobuf field: string value = 2;
     */
    value: string;
    /**
     * @generated from protobuf field: string description = 3;
     */
    description: string;
}
/**
 * Extract
 *
 * @generated from protobuf message ExtractRequest
 */
export interface ExtractRequest {
    /**
     * @generated from protobuf field: ProcessorID processor_id = 1;
     */
    processorId: ProcessorID;
    /**
     * @generated from protobuf field: map<string, ImportFiles> files = 2;
     */
    files: {
        [key: string]: ImportFiles;
    };
}
/**
 * @generated from protobuf message ExtractReply
 */
export interface ExtractReply {
    /**
     * @generated from protobuf field: ImportResult result = 1;
     */
    result?: ImportResult;
}
/**
 * Import
 *
 * @generated from protobuf message ImportRequest
 */
export interface ImportRequest {
    /**
     * @generated from protobuf field: ProcessorID processor_id = 1;
     */
    processorId: ProcessorID;
    /**
     * @generated from protobuf field: map<string, ImportFiles> files = 2;
     */
    files: {
        [key: string]: ImportFiles;
    };
}
/**
 * @generated from protobuf message ImportReply
 */
export interface ImportReply {
    /**
     * @generated from protobuf field: ImportResult result = 1;
     */
    result?: ImportResult;
}
/**
 * Get Sample File
 *
 * @generated from protobuf message GetSampleFileRequest
 */
export interface GetSampleFileRequest {
    /**
     * @generated from protobuf field: ProcessorID processor_id = 1;
     */
    processorId: ProcessorID;
}
/**
 * @generated from protobuf message GetSampleFileReply
 */
export interface GetSampleFileReply {
    /**
     * @generated from protobuf field: string file_path = 1;
     */
    filePath: string;
}
/**
 * @generated from protobuf enum ProcessorID
 */
export enum ProcessorID {
    /**
     * @generated from protobuf enum value: PROCESSOR_UNKNOWN = 0;
     */
    PROCESSOR_UNKNOWN = 0,
    /**
     * Fuel
     *
     * @generated from protobuf enum value: FUEL_TCS = 1;
     */
    FUEL_TCS = 1,
    /**
     * @generated from protobuf enum value: FUEL_FLEET_ONE = 2;
     */
    FUEL_FLEET_ONE = 2,
    /**
     * @generated from protobuf enum value: FUEL_PILOT = 3;
     */
    FUEL_PILOT = 3,
    /**
     * @generated from protobuf enum value: FUEL_LOVES = 4;
     */
    FUEL_LOVES = 4,
    /**
     * @generated from protobuf enum value: FUEL_FUELSMART = 7;
     */
    FUEL_FUELSMART = 7,
    /**
     * @generated from protobuf enum value: FUEL_LOAD_CONNEX = 12;
     */
    FUEL_LOAD_CONNEX = 12,
    /**
     * @generated from protobuf enum value: FUEL_FLEETSMART = 14;
     */
    FUEL_FLEETSMART = 14,
    /**
     * @generated from protobuf enum value: FUEL_TCS_DRIVERS_SUMMARY = 15;
     */
    FUEL_TCS_DRIVERS_SUMMARY = 15,
    /**
     * Tolls
     *
     * @generated from protobuf enum value: TOLLS_PRE_PASS = 5;
     */
    TOLLS_PRE_PASS = 5,
    /**
     * @generated from protobuf enum value: TOLLS_DEFAULT = 8;
     */
    TOLLS_DEFAULT = 8,
    /**
     * @generated from protobuf enum value: TOLLS_BESTPASS = 13;
     */
    TOLLS_BESTPASS = 13,
    /**
     * Loads
     *
     * @generated from protobuf enum value: LOADS_AMAZON = 6;
     */
    LOADS_AMAZON = 6,
    /**
     * Drivers
     *
     * @generated from protobuf enum value: DRIVERS_DEFAULT = 9;
     */
    DRIVERS_DEFAULT = 9,
    /**
     * Trucks
     *
     * @generated from protobuf enum value: TRUCKS_DEFAULT = 10;
     */
    TRUCKS_DEFAULT = 10,
    /**
     * Trailers
     *
     * @generated from protobuf enum value: TRAILERS_DEFAULT = 11;
     */
    TRAILERS_DEFAULT = 11,
    /**
     * Brokers
     *
     * @generated from protobuf enum value: BROKERS_DEFAULT = 16;
     */
    BROKERS_DEFAULT = 16,
    /**
     * Customers
     *
     * @generated from protobuf enum value: CUSTOMERS_DEFAULT = 17;
     */
    CUSTOMERS_DEFAULT = 17
}
// @generated message type with reflection information, may provide speed optimized methods
class ImportFiles$Type extends MessageType<ImportFiles> {
    constructor() {
        super('ImportFiles', [
            {
                no: 1,
                name: 'file_path',
                kind: 'scalar',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 9 /*ScalarType.STRING*/
            }
        ]);
    }
    create(value?: PartialMessage<ImportFiles>): ImportFiles {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.filePath = [];
        if (value !== undefined) reflectionMergePartial<ImportFiles>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: ImportFiles
    ): ImportFiles {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string file_path */ 1:
                    message.filePath.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: ImportFiles,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated string file_path = 1; */
        for (let i = 0; i < message.filePath.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.filePath[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ImportFiles
 */
export const ImportFiles = new ImportFiles$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportResult$Type extends MessageType<ImportResult> {
    constructor() {
        super('ImportResult', [
            {
                no: 1,
                name: 'columns',
                kind: 'map',
                K: 9 /*ScalarType.STRING*/,
                V: { kind: 'message', T: () => ImportResult_Column }
            },
            {
                no: 2,
                name: 'rows',
                kind: 'message',
                repeat: 1 /*RepeatType.PACKED*/,
                T: () => ImportResult_Row
            },
            { no: 3, name: 'stats', kind: 'message', T: () => ImportResult_Stats }
        ]);
    }
    create(value?: PartialMessage<ImportResult>): ImportResult {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.columns = {};
        message.rows = [];
        if (value !== undefined) reflectionMergePartial<ImportResult>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: ImportResult
    ): ImportResult {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, ImportResult.Column> columns */ 1:
                    this.binaryReadMap1(message.columns, reader, options);
                    break;
                case /* repeated ImportResult.Row rows */ 2:
                    message.rows.push(
                        ImportResult_Row.internalBinaryRead(reader, reader.uint32(), options)
                    );
                    break;
                case /* ImportResult.Stats stats */ 3:
                    message.stats = ImportResult_Stats.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.stats
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    private binaryReadMap1(
        map: ImportResult['columns'],
        reader: IBinaryReader,
        options: BinaryReadOptions
    ): void {
        let len = reader.uint32(),
            end = reader.pos + len,
            key: keyof ImportResult['columns'] | undefined,
            val: ImportResult['columns'][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = ImportResult_Column.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default:
                    throw new globalThis.Error(
                        'unknown map entry field for field ImportResult.columns'
                    );
            }
        }
        map[key ?? ''] = val ?? ImportResult_Column.create();
    }
    internalBinaryWrite(
        message: ImportResult,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* map<string, ImportResult.Column> columns = 1; */
        for (let k of globalThis.Object.keys(message.columns)) {
            writer
                .tag(1, WireType.LengthDelimited)
                .fork()
                .tag(1, WireType.LengthDelimited)
                .string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            ImportResult_Column.internalBinaryWrite(message.columns[k], writer, options);
            writer.join().join();
        }
        /* repeated ImportResult.Row rows = 2; */
        for (let i = 0; i < message.rows.length; i++)
            ImportResult_Row.internalBinaryWrite(
                message.rows[i],
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join();
        /* ImportResult.Stats stats = 3; */
        if (message.stats)
            ImportResult_Stats.internalBinaryWrite(
                message.stats,
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ImportResult
 */
export const ImportResult = new ImportResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportResult_Column$Type extends MessageType<ImportResult_Column> {
    constructor() {
        super('ImportResult.Column', [
            { no: 1, name: 'id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            {
                no: 3,
                name: 'width',
                kind: 'scalar',
                T: 3 /*ScalarType.INT64*/,
                L: 2 /*LongType.NUMBER*/
            },
            { no: 4, name: 'required', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: 'sticky', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: 'sample_value', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            {
                no: 7,
                name: 'position',
                kind: 'scalar',
                T: 3 /*ScalarType.INT64*/,
                L: 2 /*LongType.NUMBER*/
            }
        ]);
    }
    create(value?: PartialMessage<ImportResult_Column>): ImportResult_Column {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.id = '';
        message.name = '';
        message.width = 0;
        message.required = false;
        message.sticky = false;
        message.sampleValue = '';
        message.position = 0;
        if (value !== undefined) reflectionMergePartial<ImportResult_Column>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: ImportResult_Column
    ): ImportResult_Column {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* int64 width */ 3:
                    message.width = reader.int64().toNumber();
                    break;
                case /* bool required */ 4:
                    message.required = reader.bool();
                    break;
                case /* bool sticky */ 5:
                    message.sticky = reader.bool();
                    break;
                case /* string sample_value */ 6:
                    message.sampleValue = reader.string();
                    break;
                case /* int64 position */ 7:
                    message.position = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: ImportResult_Column,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== '') writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== '') writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* int64 width = 3; */
        if (message.width !== 0) writer.tag(3, WireType.Varint).int64(message.width);
        /* bool required = 4; */
        if (message.required !== false) writer.tag(4, WireType.Varint).bool(message.required);
        /* bool sticky = 5; */
        if (message.sticky !== false) writer.tag(5, WireType.Varint).bool(message.sticky);
        /* string sample_value = 6; */
        if (message.sampleValue !== '')
            writer.tag(6, WireType.LengthDelimited).string(message.sampleValue);
        /* int64 position = 7; */
        if (message.position !== 0) writer.tag(7, WireType.Varint).int64(message.position);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ImportResult.Column
 */
export const ImportResult_Column = new ImportResult_Column$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportResult_Row$Type extends MessageType<ImportResult_Row> {
    constructor() {
        super('ImportResult.Row', [
            {
                no: 1,
                name: 'cells',
                kind: 'map',
                K: 9 /*ScalarType.STRING*/,
                V: { kind: 'message', T: () => ImportResult_Row_Cell }
            },
            { no: 2, name: 'has_errors', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
            {
                no: 3,
                name: 'errors',
                kind: 'message',
                repeat: 1 /*RepeatType.PACKED*/,
                T: () => ImportResult_Row_Error
            },
            { no: 4, name: 'imported', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
            {
                no: 5,
                name: 'data',
                kind: 'scalar',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 9 /*ScalarType.STRING*/
            }
        ]);
    }
    create(value?: PartialMessage<ImportResult_Row>): ImportResult_Row {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.cells = {};
        message.hasErrors = false;
        message.errors = [];
        message.imported = false;
        message.data = [];
        if (value !== undefined) reflectionMergePartial<ImportResult_Row>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: ImportResult_Row
    ): ImportResult_Row {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, ImportResult.Row.Cell> cells */ 1:
                    this.binaryReadMap1(message.cells, reader, options);
                    break;
                case /* bool has_errors */ 2:
                    message.hasErrors = reader.bool();
                    break;
                case /* repeated ImportResult.Row.Error errors */ 3:
                    message.errors.push(
                        ImportResult_Row_Error.internalBinaryRead(reader, reader.uint32(), options)
                    );
                    break;
                case /* bool imported */ 4:
                    message.imported = reader.bool();
                    break;
                case /* repeated string data */ 5:
                    message.data.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    private binaryReadMap1(
        map: ImportResult_Row['cells'],
        reader: IBinaryReader,
        options: BinaryReadOptions
    ): void {
        let len = reader.uint32(),
            end = reader.pos + len,
            key: keyof ImportResult_Row['cells'] | undefined,
            val: ImportResult_Row['cells'][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = ImportResult_Row_Cell.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options
                    );
                    break;
                default:
                    throw new globalThis.Error(
                        'unknown map entry field for field ImportResult.Row.cells'
                    );
            }
        }
        map[key ?? ''] = val ?? ImportResult_Row_Cell.create();
    }
    internalBinaryWrite(
        message: ImportResult_Row,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* map<string, ImportResult.Row.Cell> cells = 1; */
        for (let k of globalThis.Object.keys(message.cells)) {
            writer
                .tag(1, WireType.LengthDelimited)
                .fork()
                .tag(1, WireType.LengthDelimited)
                .string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            ImportResult_Row_Cell.internalBinaryWrite(message.cells[k], writer, options);
            writer.join().join();
        }
        /* bool has_errors = 2; */
        if (message.hasErrors !== false) writer.tag(2, WireType.Varint).bool(message.hasErrors);
        /* repeated ImportResult.Row.Error errors = 3; */
        for (let i = 0; i < message.errors.length; i++)
            ImportResult_Row_Error.internalBinaryWrite(
                message.errors[i],
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join();
        /* bool imported = 4; */
        if (message.imported !== false) writer.tag(4, WireType.Varint).bool(message.imported);
        /* repeated string data = 5; */
        for (let i = 0; i < message.data.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.data[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ImportResult.Row
 */
export const ImportResult_Row = new ImportResult_Row$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportResult_Row_Error$Type extends MessageType<ImportResult_Row_Error> {
    constructor() {
        super('ImportResult.Row.Error', [
            { no: 1, name: 'label', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: 'value', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: 'description', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ImportResult_Row_Error>): ImportResult_Row_Error {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.label = '';
        message.value = '';
        message.description = '';
        if (value !== undefined)
            reflectionMergePartial<ImportResult_Row_Error>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: ImportResult_Row_Error
    ): ImportResult_Row_Error {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string label */ 1:
                    message.label = reader.string();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: ImportResult_Row_Error,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string label = 1; */
        if (message.label !== '') writer.tag(1, WireType.LengthDelimited).string(message.label);
        /* string value = 2; */
        if (message.value !== '') writer.tag(2, WireType.LengthDelimited).string(message.value);
        /* string description = 3; */
        if (message.description !== '')
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ImportResult.Row.Error
 */
export const ImportResult_Row_Error = new ImportResult_Row_Error$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportResult_Row_Cell$Type extends MessageType<ImportResult_Row_Cell> {
    constructor() {
        super('ImportResult.Row.Cell', [
            {
                no: 1,
                name: 'status',
                kind: 'enum',
                T: () => ['ImportResult.Row.Cell.Status', ImportResult_Row_Cell_Status]
            },
            { no: 2, name: 'value', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            {
                no: 3,
                name: 'errors',
                kind: 'message',
                repeat: 1 /*RepeatType.PACKED*/,
                T: () => ImportResult_Row_Error
            }
        ]);
    }
    create(value?: PartialMessage<ImportResult_Row_Cell>): ImportResult_Row_Cell {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.status = 0;
        message.value = '';
        message.errors = [];
        if (value !== undefined)
            reflectionMergePartial<ImportResult_Row_Cell>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: ImportResult_Row_Cell
    ): ImportResult_Row_Cell {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ImportResult.Row.Cell.Status status */ 1:
                    message.status = reader.int32();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                case /* repeated ImportResult.Row.Error errors */ 3:
                    message.errors.push(
                        ImportResult_Row_Error.internalBinaryRead(reader, reader.uint32(), options)
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: ImportResult_Row_Cell,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* ImportResult.Row.Cell.Status status = 1; */
        if (message.status !== 0) writer.tag(1, WireType.Varint).int32(message.status);
        /* string value = 2; */
        if (message.value !== '') writer.tag(2, WireType.LengthDelimited).string(message.value);
        /* repeated ImportResult.Row.Error errors = 3; */
        for (let i = 0; i < message.errors.length; i++)
            ImportResult_Row_Error.internalBinaryWrite(
                message.errors[i],
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ImportResult.Row.Cell
 */
export const ImportResult_Row_Cell = new ImportResult_Row_Cell$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportResult_Stats$Type extends MessageType<ImportResult_Stats> {
    constructor() {
        super('ImportResult.Stats', [
            { no: 1, name: 'total_rows', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: 'total_rows_valid', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: 'total_rows_invalid', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
            {
                no: 4,
                name: 'rows_group_by_error',
                kind: 'message',
                repeat: 1 /*RepeatType.PACKED*/,
                T: () => ImportResult_Stats_Error
            }
        ]);
    }
    create(value?: PartialMessage<ImportResult_Stats>): ImportResult_Stats {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.totalRows = 0;
        message.totalRowsValid = 0;
        message.totalRowsInvalid = 0;
        message.rowsGroupByError = [];
        if (value !== undefined) reflectionMergePartial<ImportResult_Stats>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: ImportResult_Stats
    ): ImportResult_Stats {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 total_rows */ 1:
                    message.totalRows = reader.int32();
                    break;
                case /* int32 total_rows_valid */ 2:
                    message.totalRowsValid = reader.int32();
                    break;
                case /* int32 total_rows_invalid */ 3:
                    message.totalRowsInvalid = reader.int32();
                    break;
                case /* repeated ImportResult.Stats.Error rows_group_by_error */ 4:
                    message.rowsGroupByError.push(
                        ImportResult_Stats_Error.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: ImportResult_Stats,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* int32 total_rows = 1; */
        if (message.totalRows !== 0) writer.tag(1, WireType.Varint).int32(message.totalRows);
        /* int32 total_rows_valid = 2; */
        if (message.totalRowsValid !== 0)
            writer.tag(2, WireType.Varint).int32(message.totalRowsValid);
        /* int32 total_rows_invalid = 3; */
        if (message.totalRowsInvalid !== 0)
            writer.tag(3, WireType.Varint).int32(message.totalRowsInvalid);
        /* repeated ImportResult.Stats.Error rows_group_by_error = 4; */
        for (let i = 0; i < message.rowsGroupByError.length; i++)
            ImportResult_Stats_Error.internalBinaryWrite(
                message.rowsGroupByError[i],
                writer.tag(4, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ImportResult.Stats
 */
export const ImportResult_Stats = new ImportResult_Stats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportResult_Stats_Error$Type extends MessageType<ImportResult_Stats_Error> {
    constructor() {
        super('ImportResult.Stats.Error', [
            { no: 1, name: 'label', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: 'value', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: 'description', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            {
                no: 4,
                name: 'count',
                kind: 'scalar',
                T: 3 /*ScalarType.INT64*/,
                L: 2 /*LongType.NUMBER*/
            }
        ]);
    }
    create(value?: PartialMessage<ImportResult_Stats_Error>): ImportResult_Stats_Error {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.label = '';
        message.value = '';
        message.description = '';
        message.count = 0;
        if (value !== undefined)
            reflectionMergePartial<ImportResult_Stats_Error>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: ImportResult_Stats_Error
    ): ImportResult_Stats_Error {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string label */ 1:
                    message.label = reader.string();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* int64 count */ 4:
                    message.count = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: ImportResult_Stats_Error,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string label = 1; */
        if (message.label !== '') writer.tag(1, WireType.LengthDelimited).string(message.label);
        /* string value = 2; */
        if (message.value !== '') writer.tag(2, WireType.LengthDelimited).string(message.value);
        /* string description = 3; */
        if (message.description !== '')
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* int64 count = 4; */
        if (message.count !== 0) writer.tag(4, WireType.Varint).int64(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ImportResult.Stats.Error
 */
export const ImportResult_Stats_Error = new ImportResult_Stats_Error$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetImportConfigRequest$Type extends MessageType<GetImportConfigRequest> {
    constructor() {
        super('GetImportConfigRequest', []);
    }
    create(value?: PartialMessage<GetImportConfigRequest>): GetImportConfigRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        if (value !== undefined)
            reflectionMergePartial<GetImportConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GetImportConfigRequest
    ): GetImportConfigRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(
        message: GetImportConfigRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetImportConfigRequest
 */
export const GetImportConfigRequest = new GetImportConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetImportConfigReply$Type extends MessageType<GetImportConfigReply> {
    constructor() {
        super('GetImportConfigReply', [
            {
                no: 1,
                name: 'categories',
                kind: 'message',
                repeat: 1 /*RepeatType.PACKED*/,
                T: () => GetImportConfigReply_Category
            },
            {
                no: 2,
                name: 'errors',
                kind: 'message',
                repeat: 1 /*RepeatType.PACKED*/,
                T: () => GetImportConfigReply_Error
            }
        ]);
    }
    create(value?: PartialMessage<GetImportConfigReply>): GetImportConfigReply {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.categories = [];
        message.errors = [];
        if (value !== undefined) reflectionMergePartial<GetImportConfigReply>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GetImportConfigReply
    ): GetImportConfigReply {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated GetImportConfigReply.Category categories */ 1:
                    message.categories.push(
                        GetImportConfigReply_Category.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                case /* repeated GetImportConfigReply.Error errors */ 2:
                    message.errors.push(
                        GetImportConfigReply_Error.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: GetImportConfigReply,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated GetImportConfigReply.Category categories = 1; */
        for (let i = 0; i < message.categories.length; i++)
            GetImportConfigReply_Category.internalBinaryWrite(
                message.categories[i],
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        /* repeated GetImportConfigReply.Error errors = 2; */
        for (let i = 0; i < message.errors.length; i++)
            GetImportConfigReply_Error.internalBinaryWrite(
                message.errors[i],
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetImportConfigReply
 */
export const GetImportConfigReply = new GetImportConfigReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetImportConfigReply_Category$Type extends MessageType<GetImportConfigReply_Category> {
    constructor() {
        super('GetImportConfigReply.Category', [
            { no: 1, name: 'category_id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: 'description', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            {
                no: 5,
                name: 'processors',
                kind: 'message',
                repeat: 1 /*RepeatType.PACKED*/,
                T: () => GetImportConfigReply_Category_Processor
            }
        ]);
    }
    create(value?: PartialMessage<GetImportConfigReply_Category>): GetImportConfigReply_Category {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.categoryId = '';
        message.name = '';
        message.description = '';
        message.processors = [];
        if (value !== undefined)
            reflectionMergePartial<GetImportConfigReply_Category>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GetImportConfigReply_Category
    ): GetImportConfigReply_Category {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string category_id */ 1:
                    message.categoryId = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* repeated GetImportConfigReply.Category.Processor processors */ 5:
                    message.processors.push(
                        GetImportConfigReply_Category_Processor.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: GetImportConfigReply_Category,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string category_id = 1; */
        if (message.categoryId !== '')
            writer.tag(1, WireType.LengthDelimited).string(message.categoryId);
        /* string name = 2; */
        if (message.name !== '') writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string description = 3; */
        if (message.description !== '')
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* repeated GetImportConfigReply.Category.Processor processors = 5; */
        for (let i = 0; i < message.processors.length; i++)
            GetImportConfigReply_Category_Processor.internalBinaryWrite(
                message.processors[i],
                writer.tag(5, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetImportConfigReply.Category
 */
export const GetImportConfigReply_Category = new GetImportConfigReply_Category$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetImportConfigReply_Category_Processor$Type extends MessageType<GetImportConfigReply_Category_Processor> {
    constructor() {
        super('GetImportConfigReply.Category.Processor', [
            { no: 1, name: 'processor_id', kind: 'enum', T: () => ['ProcessorID', ProcessorID] },
            { no: 2, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: 'description', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: 'sample_file_url', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: 'icon', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            {
                no: 6,
                name: 'required_files',
                kind: 'message',
                repeat: 1 /*RepeatType.PACKED*/,
                T: () => GetImportConfigReply_Category_Processor_RequiredFile
            }
        ]);
    }
    create(
        value?: PartialMessage<GetImportConfigReply_Category_Processor>
    ): GetImportConfigReply_Category_Processor {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.processorId = 0;
        message.name = '';
        message.description = '';
        message.sampleFileUrl = '';
        message.icon = '';
        message.requiredFiles = [];
        if (value !== undefined)
            reflectionMergePartial<GetImportConfigReply_Category_Processor>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GetImportConfigReply_Category_Processor
    ): GetImportConfigReply_Category_Processor {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ProcessorID processor_id */ 1:
                    message.processorId = reader.int32();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* string sample_file_url */ 4:
                    message.sampleFileUrl = reader.string();
                    break;
                case /* string icon */ 5:
                    message.icon = reader.string();
                    break;
                case /* repeated GetImportConfigReply.Category.Processor.RequiredFile required_files */ 6:
                    message.requiredFiles.push(
                        GetImportConfigReply_Category_Processor_RequiredFile.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: GetImportConfigReply_Category_Processor,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* ProcessorID processor_id = 1; */
        if (message.processorId !== 0) writer.tag(1, WireType.Varint).int32(message.processorId);
        /* string name = 2; */
        if (message.name !== '') writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string description = 3; */
        if (message.description !== '')
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* string sample_file_url = 4; */
        if (message.sampleFileUrl !== '')
            writer.tag(4, WireType.LengthDelimited).string(message.sampleFileUrl);
        /* string icon = 5; */
        if (message.icon !== '') writer.tag(5, WireType.LengthDelimited).string(message.icon);
        /* repeated GetImportConfigReply.Category.Processor.RequiredFile required_files = 6; */
        for (let i = 0; i < message.requiredFiles.length; i++)
            GetImportConfigReply_Category_Processor_RequiredFile.internalBinaryWrite(
                message.requiredFiles[i],
                writer.tag(6, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetImportConfigReply.Category.Processor
 */
export const GetImportConfigReply_Category_Processor =
    new GetImportConfigReply_Category_Processor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetImportConfigReply_Category_Processor_RequiredFile$Type extends MessageType<GetImportConfigReply_Category_Processor_RequiredFile> {
    constructor() {
        super('GetImportConfigReply.Category.Processor.RequiredFile', [
            { no: 1, name: 'id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            {
                no: 3,
                name: 'links',
                kind: 'message',
                repeat: 1 /*RepeatType.PACKED*/,
                T: () => GetImportConfigReply_Category_Processor_RequiredFile_Link
            }
        ]);
    }
    create(
        value?: PartialMessage<GetImportConfigReply_Category_Processor_RequiredFile>
    ): GetImportConfigReply_Category_Processor_RequiredFile {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.id = '';
        message.name = '';
        message.links = [];
        if (value !== undefined)
            reflectionMergePartial<GetImportConfigReply_Category_Processor_RequiredFile>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GetImportConfigReply_Category_Processor_RequiredFile
    ): GetImportConfigReply_Category_Processor_RequiredFile {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* repeated GetImportConfigReply.Category.Processor.RequiredFile.Link links */ 3:
                    message.links.push(
                        GetImportConfigReply_Category_Processor_RequiredFile_Link.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: GetImportConfigReply_Category_Processor_RequiredFile,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== '') writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== '') writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* repeated GetImportConfigReply.Category.Processor.RequiredFile.Link links = 3; */
        for (let i = 0; i < message.links.length; i++)
            GetImportConfigReply_Category_Processor_RequiredFile_Link.internalBinaryWrite(
                message.links[i],
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetImportConfigReply.Category.Processor.RequiredFile
 */
export const GetImportConfigReply_Category_Processor_RequiredFile =
    new GetImportConfigReply_Category_Processor_RequiredFile$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetImportConfigReply_Category_Processor_RequiredFile_Link$Type extends MessageType<GetImportConfigReply_Category_Processor_RequiredFile_Link> {
    constructor() {
        super('GetImportConfigReply.Category.Processor.RequiredFile.Link', [
            { no: 1, name: 'label', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: 'hover', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: 'url', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(
        value?: PartialMessage<GetImportConfigReply_Category_Processor_RequiredFile_Link>
    ): GetImportConfigReply_Category_Processor_RequiredFile_Link {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.label = '';
        message.hover = '';
        message.url = '';
        if (value !== undefined)
            reflectionMergePartial<GetImportConfigReply_Category_Processor_RequiredFile_Link>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GetImportConfigReply_Category_Processor_RequiredFile_Link
    ): GetImportConfigReply_Category_Processor_RequiredFile_Link {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string label */ 1:
                    message.label = reader.string();
                    break;
                case /* string hover */ 2:
                    message.hover = reader.string();
                    break;
                case /* string url */ 3:
                    message.url = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: GetImportConfigReply_Category_Processor_RequiredFile_Link,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string label = 1; */
        if (message.label !== '') writer.tag(1, WireType.LengthDelimited).string(message.label);
        /* string hover = 2; */
        if (message.hover !== '') writer.tag(2, WireType.LengthDelimited).string(message.hover);
        /* string url = 3; */
        if (message.url !== '') writer.tag(3, WireType.LengthDelimited).string(message.url);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetImportConfigReply.Category.Processor.RequiredFile.Link
 */
export const GetImportConfigReply_Category_Processor_RequiredFile_Link =
    new GetImportConfigReply_Category_Processor_RequiredFile_Link$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetImportConfigReply_Error$Type extends MessageType<GetImportConfigReply_Error> {
    constructor() {
        super('GetImportConfigReply.Error', [
            { no: 1, name: 'label', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: 'value', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: 'description', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetImportConfigReply_Error>): GetImportConfigReply_Error {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.label = '';
        message.value = '';
        message.description = '';
        if (value !== undefined)
            reflectionMergePartial<GetImportConfigReply_Error>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GetImportConfigReply_Error
    ): GetImportConfigReply_Error {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string label */ 1:
                    message.label = reader.string();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: GetImportConfigReply_Error,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string label = 1; */
        if (message.label !== '') writer.tag(1, WireType.LengthDelimited).string(message.label);
        /* string value = 2; */
        if (message.value !== '') writer.tag(2, WireType.LengthDelimited).string(message.value);
        /* string description = 3; */
        if (message.description !== '')
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetImportConfigReply.Error
 */
export const GetImportConfigReply_Error = new GetImportConfigReply_Error$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExtractRequest$Type extends MessageType<ExtractRequest> {
    constructor() {
        super('ExtractRequest', [
            { no: 1, name: 'processor_id', kind: 'enum', T: () => ['ProcessorID', ProcessorID] },
            {
                no: 2,
                name: 'files',
                kind: 'map',
                K: 9 /*ScalarType.STRING*/,
                V: { kind: 'message', T: () => ImportFiles }
            }
        ]);
    }
    create(value?: PartialMessage<ExtractRequest>): ExtractRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.processorId = 0;
        message.files = {};
        if (value !== undefined) reflectionMergePartial<ExtractRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: ExtractRequest
    ): ExtractRequest {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ProcessorID processor_id */ 1:
                    message.processorId = reader.int32();
                    break;
                case /* map<string, ImportFiles> files */ 2:
                    this.binaryReadMap2(message.files, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    private binaryReadMap2(
        map: ExtractRequest['files'],
        reader: IBinaryReader,
        options: BinaryReadOptions
    ): void {
        let len = reader.uint32(),
            end = reader.pos + len,
            key: keyof ExtractRequest['files'] | undefined,
            val: ExtractRequest['files'][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = ImportFiles.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default:
                    throw new globalThis.Error(
                        'unknown map entry field for field ExtractRequest.files'
                    );
            }
        }
        map[key ?? ''] = val ?? ImportFiles.create();
    }
    internalBinaryWrite(
        message: ExtractRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* ProcessorID processor_id = 1; */
        if (message.processorId !== 0) writer.tag(1, WireType.Varint).int32(message.processorId);
        /* map<string, ImportFiles> files = 2; */
        for (let k of globalThis.Object.keys(message.files)) {
            writer
                .tag(2, WireType.LengthDelimited)
                .fork()
                .tag(1, WireType.LengthDelimited)
                .string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            ImportFiles.internalBinaryWrite(message.files[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExtractRequest
 */
export const ExtractRequest = new ExtractRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExtractReply$Type extends MessageType<ExtractReply> {
    constructor() {
        super('ExtractReply', [{ no: 1, name: 'result', kind: 'message', T: () => ImportResult }]);
    }
    create(value?: PartialMessage<ExtractReply>): ExtractReply {
        const message = globalThis.Object.create(this.messagePrototype!);
        if (value !== undefined) reflectionMergePartial<ExtractReply>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: ExtractReply
    ): ExtractReply {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ImportResult result */ 1:
                    message.result = ImportResult.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.result
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: ExtractReply,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* ImportResult result = 1; */
        if (message.result)
            ImportResult.internalBinaryWrite(
                message.result,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExtractReply
 */
export const ExtractReply = new ExtractReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportRequest$Type extends MessageType<ImportRequest> {
    constructor() {
        super('ImportRequest', [
            { no: 1, name: 'processor_id', kind: 'enum', T: () => ['ProcessorID', ProcessorID] },
            {
                no: 2,
                name: 'files',
                kind: 'map',
                K: 9 /*ScalarType.STRING*/,
                V: { kind: 'message', T: () => ImportFiles }
            }
        ]);
    }
    create(value?: PartialMessage<ImportRequest>): ImportRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.processorId = 0;
        message.files = {};
        if (value !== undefined) reflectionMergePartial<ImportRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: ImportRequest
    ): ImportRequest {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ProcessorID processor_id */ 1:
                    message.processorId = reader.int32();
                    break;
                case /* map<string, ImportFiles> files */ 2:
                    this.binaryReadMap2(message.files, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    private binaryReadMap2(
        map: ImportRequest['files'],
        reader: IBinaryReader,
        options: BinaryReadOptions
    ): void {
        let len = reader.uint32(),
            end = reader.pos + len,
            key: keyof ImportRequest['files'] | undefined,
            val: ImportRequest['files'][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = ImportFiles.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default:
                    throw new globalThis.Error(
                        'unknown map entry field for field ImportRequest.files'
                    );
            }
        }
        map[key ?? ''] = val ?? ImportFiles.create();
    }
    internalBinaryWrite(
        message: ImportRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* ProcessorID processor_id = 1; */
        if (message.processorId !== 0) writer.tag(1, WireType.Varint).int32(message.processorId);
        /* map<string, ImportFiles> files = 2; */
        for (let k of globalThis.Object.keys(message.files)) {
            writer
                .tag(2, WireType.LengthDelimited)
                .fork()
                .tag(1, WireType.LengthDelimited)
                .string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            ImportFiles.internalBinaryWrite(message.files[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ImportRequest
 */
export const ImportRequest = new ImportRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportReply$Type extends MessageType<ImportReply> {
    constructor() {
        super('ImportReply', [{ no: 1, name: 'result', kind: 'message', T: () => ImportResult }]);
    }
    create(value?: PartialMessage<ImportReply>): ImportReply {
        const message = globalThis.Object.create(this.messagePrototype!);
        if (value !== undefined) reflectionMergePartial<ImportReply>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: ImportReply
    ): ImportReply {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ImportResult result */ 1:
                    message.result = ImportResult.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.result
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: ImportReply,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* ImportResult result = 1; */
        if (message.result)
            ImportResult.internalBinaryWrite(
                message.result,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ImportReply
 */
export const ImportReply = new ImportReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSampleFileRequest$Type extends MessageType<GetSampleFileRequest> {
    constructor() {
        super('GetSampleFileRequest', [
            { no: 1, name: 'processor_id', kind: 'enum', T: () => ['ProcessorID', ProcessorID] }
        ]);
    }
    create(value?: PartialMessage<GetSampleFileRequest>): GetSampleFileRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.processorId = 0;
        if (value !== undefined) reflectionMergePartial<GetSampleFileRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GetSampleFileRequest
    ): GetSampleFileRequest {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ProcessorID processor_id */ 1:
                    message.processorId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: GetSampleFileRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* ProcessorID processor_id = 1; */
        if (message.processorId !== 0) writer.tag(1, WireType.Varint).int32(message.processorId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetSampleFileRequest
 */
export const GetSampleFileRequest = new GetSampleFileRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSampleFileReply$Type extends MessageType<GetSampleFileReply> {
    constructor() {
        super('GetSampleFileReply', [
            { no: 1, name: 'file_path', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetSampleFileReply>): GetSampleFileReply {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.filePath = '';
        if (value !== undefined) reflectionMergePartial<GetSampleFileReply>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GetSampleFileReply
    ): GetSampleFileReply {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string file_path */ 1:
                    message.filePath = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: GetSampleFileReply,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string file_path = 1; */
        if (message.filePath !== '')
            writer.tag(1, WireType.LengthDelimited).string(message.filePath);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetSampleFileReply
 */
export const GetSampleFileReply = new GetSampleFileReply$Type();
/**
 * @generated ServiceType for protobuf service ImportService
 */
export const ImportService = new ServiceType('ImportService', [
    { name: 'GetImportConfig', options: {}, I: GetImportConfigRequest, O: GetImportConfigReply },
    { name: 'Extract', options: {}, I: ExtractRequest, O: ExtractReply },
    { name: 'Import', options: {}, I: ImportRequest, O: ImportReply },
    { name: 'GetSampleFile', options: {}, I: GetSampleFileRequest, O: GetSampleFileReply }
]);
