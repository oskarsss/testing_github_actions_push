// @generated by protobuf-ts 2.9.4 with parameter long_type_number,generate_dependencies,ts_nocheck,output_typescript
// @generated from protobuf file "v1/export.proto" (syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from '@protobuf-ts/runtime-rpc';
import { WireType } from '@protobuf-ts/runtime';
import type { BinaryWriteOptions } from '@protobuf-ts/runtime';
import type { IBinaryWriter } from '@protobuf-ts/runtime';
import { UnknownFieldHandler } from '@protobuf-ts/runtime';
import type { BinaryReadOptions } from '@protobuf-ts/runtime';
import type { IBinaryReader } from '@protobuf-ts/runtime';
import type { PartialMessage } from '@protobuf-ts/runtime';
import { reflectionMergePartial } from '@protobuf-ts/runtime';
import { MessageType } from '@protobuf-ts/runtime';
import { FilterModel_FilterID } from './models/model_filter_type';
/**
 * GetExportConfig
 *
 * @generated from protobuf message GetExportConfigRequest
 */
export interface GetExportConfigRequest {}
/**
 * @generated from protobuf message GetExportConfigReply
 */
export interface GetExportConfigReply {
    /**
     * @generated from protobuf field: repeated GetExportConfigReply.Exporter exporters = 1;
     */
    exporters: GetExportConfigReply_Exporter[];
}
/**
 * @generated from protobuf message GetExportConfigReply.Exporter
 */
export interface GetExportConfigReply_Exporter {
    /**
     * @generated from protobuf field: ExporterID exporter_id = 1;
     */
    exporterId: ExporterID;
    /**
     * @generated from protobuf field: string label = 2;
     */
    label: string;
    /**
     * @generated from protobuf field: repeated GetExportConfigReply.Exporter.Type types = 3;
     */
    types: GetExportConfigReply_Exporter_Type[];
}
/**
 * @generated from protobuf message GetExportConfigReply.Exporter.Type
 */
export interface GetExportConfigReply_Exporter_Type {
    /**
     * @generated from protobuf field: string exporter_type_id = 1;
     */
    exporterTypeId: string;
    /**
     * @generated from protobuf field: string label = 2;
     */
    label: string;
    /**
     * @generated from protobuf field: string description = 3;
     */
    description: string;
    /**
     * @generated from protobuf field: repeated GetExportConfigReply.Exporter.Type.Filter filters = 4;
     */
    filters: GetExportConfigReply_Exporter_Type_Filter[];
    /**
     * @generated from protobuf field: repeated GetExportConfigReply.Exporter.Type.Column columns = 5;
     */
    columns: GetExportConfigReply_Exporter_Type_Column[];
}
/**
 * @generated from protobuf message GetExportConfigReply.Exporter.Type.Filter
 */
export interface GetExportConfigReply_Exporter_Type_Filter {
    /**
     * @generated from protobuf field: FilterModel.FilterID filter_id = 1;
     */
    filterId: FilterModel_FilterID;
    /**
     * @generated from protobuf field: string label = 2;
     */
    label: string;
    /**
     * @generated from protobuf field: bool required = 3;
     */
    required: boolean;
}
/**
 * @generated from protobuf message GetExportConfigReply.Exporter.Type.Column
 */
export interface GetExportConfigReply_Exporter_Type_Column {
    /**
     * @generated from protobuf field: string column_id = 1;
     */
    columnId: string;
    /**
     * @generated from protobuf field: string label = 2;
     */
    label: string;
}
/**
 * DownloadExport
 *
 * @generated from protobuf message DownloadExportRequest
 */
export interface DownloadExportRequest {
    /**
     * @generated from protobuf field: ExporterID exporter_id = 1;
     */
    exporterId: ExporterID;
    /**
     * @generated from protobuf field: string exporter_type_id = 2;
     */
    exporterTypeId: string;
    /**
     * @generated from protobuf field: repeated DownloadExportRequest.FilterValue filter_values = 3;
     */
    filterValues: DownloadExportRequest_FilterValue[];
    /**
     * @generated from protobuf field: repeated string columns = 4;
     */
    columns: string[];
}
/**
 * @generated from protobuf message DownloadExportRequest.FilterValue
 */
export interface DownloadExportRequest_FilterValue {
    /**
     * @generated from protobuf field: FilterModel.FilterID filter_id = 1;
     */
    filterId: FilterModel_FilterID;
    /**
     * @generated from protobuf field: repeated string value = 2;
     */
    value: string[];
}
/**
 * @generated from protobuf message DownloadExportReply
 */
export interface DownloadExportReply {
    /**
     * @generated from protobuf field: string file_path = 1;
     */
    filePath: string;
}
/**
 * ExportAllInvoices
 *
 * @generated from protobuf message ExportAllInvoicesRequest
 */
export interface ExportAllInvoicesRequest {}
/**
 * @generated from protobuf message ExportAllInvoicesReply
 */
export interface ExportAllInvoicesReply {
    /**
     * @generated from protobuf field: string file_path = 1;
     */
    filePath: string;
}
/**
 * ExportFactoringInvoices
 *
 * @generated from protobuf message ExportFactoringInvoicesRequest
 */
export interface ExportFactoringInvoicesRequest {
    /**
     * @generated from protobuf field: string factoring_company_id = 1;
     */
    factoringCompanyId: string;
}
/**
 * @generated from protobuf message ExportFactoringInvoicesReply
 */
export interface ExportFactoringInvoicesReply {
    /**
     * @generated from protobuf field: string file_path = 1;
     */
    filePath: string;
}
/**
 * ExportDirectInvoices
 *
 * @generated from protobuf message ExportDirectInvoicesRequest
 */
export interface ExportDirectInvoicesRequest {}
/**
 * @generated from protobuf message ExportDirectInvoicesReply
 */
export interface ExportDirectInvoicesReply {
    /**
     * @generated from protobuf field: string file_path = 1;
     */
    filePath: string;
}
/**
 * Enums for identifying exporters and parameter types.
 *
 * @generated from protobuf enum ExporterID
 */
export enum ExporterID {
    /**
     * @generated from protobuf enum value: UNKNOWN_EXPORTER_ID = 0;
     */
    UNKNOWN_EXPORTER_ID = 0,
    /**
     * @generated from protobuf enum value: INVOICES_EXPORTER = 1;
     */
    INVOICES_EXPORTER = 1,
    /**
     * @generated from protobuf enum value: LOADS_EXPORTER = 2;
     */
    LOADS_EXPORTER = 2,
    /**
     * @generated from protobuf enum value: TRUCKS_EXPORTER = 3;
     */
    TRUCKS_EXPORTER = 3,
    /**
     * @generated from protobuf enum value: TRAILERS_EXPORTER = 4;
     */
    TRAILERS_EXPORTER = 4,
    /**
     * @generated from protobuf enum value: DRIVERS_EXPORTER = 5;
     */
    DRIVERS_EXPORTER = 5,
    /**
     * @generated from protobuf enum value: TOLLS_EXPORTER = 6;
     */
    TOLLS_EXPORTER = 6,
    /**
     * @generated from protobuf enum value: FUEL_EXPORTER = 7;
     */
    FUEL_EXPORTER = 7,
    /**
     * @generated from protobuf enum value: SETTLEMENTS_EXPORTER = 8;
     */
    SETTLEMENTS_EXPORTER = 8,
    /**
     * @generated from protobuf enum value: RECURRING_EXPORTER = 9;
     */
    RECURRING_EXPORTER = 9,
    /**
     * @generated from protobuf enum value: PLATES_EXPORTER = 10;
     */
    PLATES_EXPORTER = 10,
    /**
     * @generated from protobuf enum value: VENDORS_EXPORTER = 11;
     */
    VENDORS_EXPORTER = 11,
    /**
     * @generated from protobuf enum value: BROKERS_EXPORTER = 12;
     */
    BROKERS_EXPORTER = 12,
    /**
     * @generated from protobuf enum value: CUSTOMERS_EXPORTER = 13;
     */
    CUSTOMERS_EXPORTER = 13
}
// @generated message type with reflection information, may provide speed optimized methods
class GetExportConfigRequest$Type extends MessageType<GetExportConfigRequest> {
    constructor() {
        super('GetExportConfigRequest', []);
    }
    create(value?: PartialMessage<GetExportConfigRequest>): GetExportConfigRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        if (value !== undefined)
            reflectionMergePartial<GetExportConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GetExportConfigRequest
    ): GetExportConfigRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(
        message: GetExportConfigRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetExportConfigRequest
 */
export const GetExportConfigRequest = new GetExportConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetExportConfigReply$Type extends MessageType<GetExportConfigReply> {
    constructor() {
        super('GetExportConfigReply', [
            {
                no: 1,
                name: 'exporters',
                kind: 'message',
                repeat: 1 /*RepeatType.PACKED*/,
                T: () => GetExportConfigReply_Exporter
            }
        ]);
    }
    create(value?: PartialMessage<GetExportConfigReply>): GetExportConfigReply {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.exporters = [];
        if (value !== undefined) reflectionMergePartial<GetExportConfigReply>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GetExportConfigReply
    ): GetExportConfigReply {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated GetExportConfigReply.Exporter exporters */ 1:
                    message.exporters.push(
                        GetExportConfigReply_Exporter.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: GetExportConfigReply,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated GetExportConfigReply.Exporter exporters = 1; */
        for (let i = 0; i < message.exporters.length; i++)
            GetExportConfigReply_Exporter.internalBinaryWrite(
                message.exporters[i],
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetExportConfigReply
 */
export const GetExportConfigReply = new GetExportConfigReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetExportConfigReply_Exporter$Type extends MessageType<GetExportConfigReply_Exporter> {
    constructor() {
        super('GetExportConfigReply.Exporter', [
            { no: 1, name: 'exporter_id', kind: 'enum', T: () => ['ExporterID', ExporterID] },
            { no: 2, name: 'label', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            {
                no: 3,
                name: 'types',
                kind: 'message',
                repeat: 1 /*RepeatType.PACKED*/,
                T: () => GetExportConfigReply_Exporter_Type
            }
        ]);
    }
    create(value?: PartialMessage<GetExportConfigReply_Exporter>): GetExportConfigReply_Exporter {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.exporterId = 0;
        message.label = '';
        message.types = [];
        if (value !== undefined)
            reflectionMergePartial<GetExportConfigReply_Exporter>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GetExportConfigReply_Exporter
    ): GetExportConfigReply_Exporter {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ExporterID exporter_id */ 1:
                    message.exporterId = reader.int32();
                    break;
                case /* string label */ 2:
                    message.label = reader.string();
                    break;
                case /* repeated GetExportConfigReply.Exporter.Type types */ 3:
                    message.types.push(
                        GetExportConfigReply_Exporter_Type.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: GetExportConfigReply_Exporter,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* ExporterID exporter_id = 1; */
        if (message.exporterId !== 0) writer.tag(1, WireType.Varint).int32(message.exporterId);
        /* string label = 2; */
        if (message.label !== '') writer.tag(2, WireType.LengthDelimited).string(message.label);
        /* repeated GetExportConfigReply.Exporter.Type types = 3; */
        for (let i = 0; i < message.types.length; i++)
            GetExportConfigReply_Exporter_Type.internalBinaryWrite(
                message.types[i],
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetExportConfigReply.Exporter
 */
export const GetExportConfigReply_Exporter = new GetExportConfigReply_Exporter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetExportConfigReply_Exporter_Type$Type extends MessageType<GetExportConfigReply_Exporter_Type> {
    constructor() {
        super('GetExportConfigReply.Exporter.Type', [
            { no: 1, name: 'exporter_type_id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: 'label', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: 'description', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            {
                no: 4,
                name: 'filters',
                kind: 'message',
                repeat: 1 /*RepeatType.PACKED*/,
                T: () => GetExportConfigReply_Exporter_Type_Filter
            },
            {
                no: 5,
                name: 'columns',
                kind: 'message',
                repeat: 1 /*RepeatType.PACKED*/,
                T: () => GetExportConfigReply_Exporter_Type_Column
            }
        ]);
    }
    create(
        value?: PartialMessage<GetExportConfigReply_Exporter_Type>
    ): GetExportConfigReply_Exporter_Type {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.exporterTypeId = '';
        message.label = '';
        message.description = '';
        message.filters = [];
        message.columns = [];
        if (value !== undefined)
            reflectionMergePartial<GetExportConfigReply_Exporter_Type>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GetExportConfigReply_Exporter_Type
    ): GetExportConfigReply_Exporter_Type {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string exporter_type_id */ 1:
                    message.exporterTypeId = reader.string();
                    break;
                case /* string label */ 2:
                    message.label = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* repeated GetExportConfigReply.Exporter.Type.Filter filters */ 4:
                    message.filters.push(
                        GetExportConfigReply_Exporter_Type_Filter.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                case /* repeated GetExportConfigReply.Exporter.Type.Column columns */ 5:
                    message.columns.push(
                        GetExportConfigReply_Exporter_Type_Column.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: GetExportConfigReply_Exporter_Type,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string exporter_type_id = 1; */
        if (message.exporterTypeId !== '')
            writer.tag(1, WireType.LengthDelimited).string(message.exporterTypeId);
        /* string label = 2; */
        if (message.label !== '') writer.tag(2, WireType.LengthDelimited).string(message.label);
        /* string description = 3; */
        if (message.description !== '')
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* repeated GetExportConfigReply.Exporter.Type.Filter filters = 4; */
        for (let i = 0; i < message.filters.length; i++)
            GetExportConfigReply_Exporter_Type_Filter.internalBinaryWrite(
                message.filters[i],
                writer.tag(4, WireType.LengthDelimited).fork(),
                options
            ).join();
        /* repeated GetExportConfigReply.Exporter.Type.Column columns = 5; */
        for (let i = 0; i < message.columns.length; i++)
            GetExportConfigReply_Exporter_Type_Column.internalBinaryWrite(
                message.columns[i],
                writer.tag(5, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetExportConfigReply.Exporter.Type
 */
export const GetExportConfigReply_Exporter_Type = new GetExportConfigReply_Exporter_Type$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetExportConfigReply_Exporter_Type_Filter$Type extends MessageType<GetExportConfigReply_Exporter_Type_Filter> {
    constructor() {
        super('GetExportConfigReply.Exporter.Type.Filter', [
            {
                no: 1,
                name: 'filter_id',
                kind: 'enum',
                T: () => ['FilterModel.FilterID', FilterModel_FilterID]
            },
            { no: 2, name: 'label', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: 'required', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(
        value?: PartialMessage<GetExportConfigReply_Exporter_Type_Filter>
    ): GetExportConfigReply_Exporter_Type_Filter {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.filterId = 0;
        message.label = '';
        message.required = false;
        if (value !== undefined)
            reflectionMergePartial<GetExportConfigReply_Exporter_Type_Filter>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GetExportConfigReply_Exporter_Type_Filter
    ): GetExportConfigReply_Exporter_Type_Filter {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* FilterModel.FilterID filter_id */ 1:
                    message.filterId = reader.int32();
                    break;
                case /* string label */ 2:
                    message.label = reader.string();
                    break;
                case /* bool required */ 3:
                    message.required = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: GetExportConfigReply_Exporter_Type_Filter,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* FilterModel.FilterID filter_id = 1; */
        if (message.filterId !== 0) writer.tag(1, WireType.Varint).int32(message.filterId);
        /* string label = 2; */
        if (message.label !== '') writer.tag(2, WireType.LengthDelimited).string(message.label);
        /* bool required = 3; */
        if (message.required !== false) writer.tag(3, WireType.Varint).bool(message.required);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetExportConfigReply.Exporter.Type.Filter
 */
export const GetExportConfigReply_Exporter_Type_Filter =
    new GetExportConfigReply_Exporter_Type_Filter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetExportConfigReply_Exporter_Type_Column$Type extends MessageType<GetExportConfigReply_Exporter_Type_Column> {
    constructor() {
        super('GetExportConfigReply.Exporter.Type.Column', [
            { no: 1, name: 'column_id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: 'label', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(
        value?: PartialMessage<GetExportConfigReply_Exporter_Type_Column>
    ): GetExportConfigReply_Exporter_Type_Column {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.columnId = '';
        message.label = '';
        if (value !== undefined)
            reflectionMergePartial<GetExportConfigReply_Exporter_Type_Column>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GetExportConfigReply_Exporter_Type_Column
    ): GetExportConfigReply_Exporter_Type_Column {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string column_id */ 1:
                    message.columnId = reader.string();
                    break;
                case /* string label */ 2:
                    message.label = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: GetExportConfigReply_Exporter_Type_Column,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string column_id = 1; */
        if (message.columnId !== '')
            writer.tag(1, WireType.LengthDelimited).string(message.columnId);
        /* string label = 2; */
        if (message.label !== '') writer.tag(2, WireType.LengthDelimited).string(message.label);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetExportConfigReply.Exporter.Type.Column
 */
export const GetExportConfigReply_Exporter_Type_Column =
    new GetExportConfigReply_Exporter_Type_Column$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DownloadExportRequest$Type extends MessageType<DownloadExportRequest> {
    constructor() {
        super('DownloadExportRequest', [
            { no: 1, name: 'exporter_id', kind: 'enum', T: () => ['ExporterID', ExporterID] },
            { no: 2, name: 'exporter_type_id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            {
                no: 3,
                name: 'filter_values',
                kind: 'message',
                repeat: 1 /*RepeatType.PACKED*/,
                T: () => DownloadExportRequest_FilterValue
            },
            {
                no: 4,
                name: 'columns',
                kind: 'scalar',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 9 /*ScalarType.STRING*/
            }
        ]);
    }
    create(value?: PartialMessage<DownloadExportRequest>): DownloadExportRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.exporterId = 0;
        message.exporterTypeId = '';
        message.filterValues = [];
        message.columns = [];
        if (value !== undefined)
            reflectionMergePartial<DownloadExportRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: DownloadExportRequest
    ): DownloadExportRequest {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ExporterID exporter_id */ 1:
                    message.exporterId = reader.int32();
                    break;
                case /* string exporter_type_id */ 2:
                    message.exporterTypeId = reader.string();
                    break;
                case /* repeated DownloadExportRequest.FilterValue filter_values */ 3:
                    message.filterValues.push(
                        DownloadExportRequest_FilterValue.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                case /* repeated string columns */ 4:
                    message.columns.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: DownloadExportRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* ExporterID exporter_id = 1; */
        if (message.exporterId !== 0) writer.tag(1, WireType.Varint).int32(message.exporterId);
        /* string exporter_type_id = 2; */
        if (message.exporterTypeId !== '')
            writer.tag(2, WireType.LengthDelimited).string(message.exporterTypeId);
        /* repeated DownloadExportRequest.FilterValue filter_values = 3; */
        for (let i = 0; i < message.filterValues.length; i++)
            DownloadExportRequest_FilterValue.internalBinaryWrite(
                message.filterValues[i],
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join();
        /* repeated string columns = 4; */
        for (let i = 0; i < message.columns.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.columns[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DownloadExportRequest
 */
export const DownloadExportRequest = new DownloadExportRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DownloadExportRequest_FilterValue$Type extends MessageType<DownloadExportRequest_FilterValue> {
    constructor() {
        super('DownloadExportRequest.FilterValue', [
            {
                no: 1,
                name: 'filter_id',
                kind: 'enum',
                T: () => ['FilterModel.FilterID', FilterModel_FilterID]
            },
            {
                no: 2,
                name: 'value',
                kind: 'scalar',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 9 /*ScalarType.STRING*/
            }
        ]);
    }
    create(
        value?: PartialMessage<DownloadExportRequest_FilterValue>
    ): DownloadExportRequest_FilterValue {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.filterId = 0;
        message.value = [];
        if (value !== undefined)
            reflectionMergePartial<DownloadExportRequest_FilterValue>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: DownloadExportRequest_FilterValue
    ): DownloadExportRequest_FilterValue {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* FilterModel.FilterID filter_id */ 1:
                    message.filterId = reader.int32();
                    break;
                case /* repeated string value */ 2:
                    message.value.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: DownloadExportRequest_FilterValue,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* FilterModel.FilterID filter_id = 1; */
        if (message.filterId !== 0) writer.tag(1, WireType.Varint).int32(message.filterId);
        /* repeated string value = 2; */
        for (let i = 0; i < message.value.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.value[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DownloadExportRequest.FilterValue
 */
export const DownloadExportRequest_FilterValue = new DownloadExportRequest_FilterValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DownloadExportReply$Type extends MessageType<DownloadExportReply> {
    constructor() {
        super('DownloadExportReply', [
            { no: 1, name: 'file_path', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DownloadExportReply>): DownloadExportReply {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.filePath = '';
        if (value !== undefined) reflectionMergePartial<DownloadExportReply>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: DownloadExportReply
    ): DownloadExportReply {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string file_path */ 1:
                    message.filePath = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: DownloadExportReply,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string file_path = 1; */
        if (message.filePath !== '')
            writer.tag(1, WireType.LengthDelimited).string(message.filePath);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DownloadExportReply
 */
export const DownloadExportReply = new DownloadExportReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExportAllInvoicesRequest$Type extends MessageType<ExportAllInvoicesRequest> {
    constructor() {
        super('ExportAllInvoicesRequest', []);
    }
    create(value?: PartialMessage<ExportAllInvoicesRequest>): ExportAllInvoicesRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        if (value !== undefined)
            reflectionMergePartial<ExportAllInvoicesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: ExportAllInvoicesRequest
    ): ExportAllInvoicesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(
        message: ExportAllInvoicesRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExportAllInvoicesRequest
 */
export const ExportAllInvoicesRequest = new ExportAllInvoicesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExportAllInvoicesReply$Type extends MessageType<ExportAllInvoicesReply> {
    constructor() {
        super('ExportAllInvoicesReply', [
            { no: 1, name: 'file_path', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExportAllInvoicesReply>): ExportAllInvoicesReply {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.filePath = '';
        if (value !== undefined)
            reflectionMergePartial<ExportAllInvoicesReply>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: ExportAllInvoicesReply
    ): ExportAllInvoicesReply {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string file_path */ 1:
                    message.filePath = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: ExportAllInvoicesReply,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string file_path = 1; */
        if (message.filePath !== '')
            writer.tag(1, WireType.LengthDelimited).string(message.filePath);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExportAllInvoicesReply
 */
export const ExportAllInvoicesReply = new ExportAllInvoicesReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExportFactoringInvoicesRequest$Type extends MessageType<ExportFactoringInvoicesRequest> {
    constructor() {
        super('ExportFactoringInvoicesRequest', [
            { no: 1, name: 'factoring_company_id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExportFactoringInvoicesRequest>): ExportFactoringInvoicesRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.factoringCompanyId = '';
        if (value !== undefined)
            reflectionMergePartial<ExportFactoringInvoicesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: ExportFactoringInvoicesRequest
    ): ExportFactoringInvoicesRequest {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string factoring_company_id */ 1:
                    message.factoringCompanyId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: ExportFactoringInvoicesRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string factoring_company_id = 1; */
        if (message.factoringCompanyId !== '')
            writer.tag(1, WireType.LengthDelimited).string(message.factoringCompanyId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExportFactoringInvoicesRequest
 */
export const ExportFactoringInvoicesRequest = new ExportFactoringInvoicesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExportFactoringInvoicesReply$Type extends MessageType<ExportFactoringInvoicesReply> {
    constructor() {
        super('ExportFactoringInvoicesReply', [
            { no: 1, name: 'file_path', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExportFactoringInvoicesReply>): ExportFactoringInvoicesReply {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.filePath = '';
        if (value !== undefined)
            reflectionMergePartial<ExportFactoringInvoicesReply>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: ExportFactoringInvoicesReply
    ): ExportFactoringInvoicesReply {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string file_path */ 1:
                    message.filePath = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: ExportFactoringInvoicesReply,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string file_path = 1; */
        if (message.filePath !== '')
            writer.tag(1, WireType.LengthDelimited).string(message.filePath);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExportFactoringInvoicesReply
 */
export const ExportFactoringInvoicesReply = new ExportFactoringInvoicesReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExportDirectInvoicesRequest$Type extends MessageType<ExportDirectInvoicesRequest> {
    constructor() {
        super('ExportDirectInvoicesRequest', []);
    }
    create(value?: PartialMessage<ExportDirectInvoicesRequest>): ExportDirectInvoicesRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        if (value !== undefined)
            reflectionMergePartial<ExportDirectInvoicesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: ExportDirectInvoicesRequest
    ): ExportDirectInvoicesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(
        message: ExportDirectInvoicesRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExportDirectInvoicesRequest
 */
export const ExportDirectInvoicesRequest = new ExportDirectInvoicesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExportDirectInvoicesReply$Type extends MessageType<ExportDirectInvoicesReply> {
    constructor() {
        super('ExportDirectInvoicesReply', [
            { no: 1, name: 'file_path', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExportDirectInvoicesReply>): ExportDirectInvoicesReply {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.filePath = '';
        if (value !== undefined)
            reflectionMergePartial<ExportDirectInvoicesReply>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: ExportDirectInvoicesReply
    ): ExportDirectInvoicesReply {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string file_path */ 1:
                    message.filePath = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: ExportDirectInvoicesReply,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string file_path = 1; */
        if (message.filePath !== '')
            writer.tag(1, WireType.LengthDelimited).string(message.filePath);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExportDirectInvoicesReply
 */
export const ExportDirectInvoicesReply = new ExportDirectInvoicesReply$Type();
/**
 * @generated ServiceType for protobuf service ExportService
 */
export const ExportService = new ServiceType('ExportService', [
    { name: 'GetExportConfig', options: {}, I: GetExportConfigRequest, O: GetExportConfigReply },
    { name: 'DownloadExport', options: {}, I: DownloadExportRequest, O: DownloadExportReply },
    {
        name: 'ExportAllInvoices',
        options: {},
        I: ExportAllInvoicesRequest,
        O: ExportAllInvoicesReply
    },
    {
        name: 'ExportFactoringInvoices',
        options: {},
        I: ExportFactoringInvoicesRequest,
        O: ExportFactoringInvoicesReply
    },
    {
        name: 'ExportDirectInvoices',
        options: {},
        I: ExportDirectInvoicesRequest,
        O: ExportDirectInvoicesReply
    }
]);
