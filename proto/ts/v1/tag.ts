// @generated by protobuf-ts 2.9.4 with parameter long_type_number,generate_dependencies,ts_nocheck,output_typescript
// @generated from protobuf file "v1/tag.proto" (syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { TagModel_EntityType } from "./models/model_tag";
/**
 * @generated from protobuf message TagCreateRequest
 */
export interface TagCreateRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: TagModel.EntityType entity_type = 2;
     */
    entityType: TagModel_EntityType;
    /**
     * @generated from protobuf field: optional string text_color = 3;
     */
    textColor?: string;
    /**
     * @generated from protobuf field: optional string background_color = 4;
     */
    backgroundColor?: string;
}
/**
 * @generated from protobuf message TagCreateReply
 */
export interface TagCreateReply {
    /**
     * @generated from protobuf field: string tag_id = 1;
     */
    tagId: string;
}
/**
 * @generated from protobuf message TagDeleteRequest
 */
export interface TagDeleteRequest {
    /**
     * @generated from protobuf field: string tag_id = 1;
     */
    tagId: string;
}
/**
 * @generated from protobuf message TagDeleteReply
 */
export interface TagDeleteReply {
}
/**
 * @generated from protobuf message TagGetRequest
 */
export interface TagGetRequest {
}
/**
 * @generated from protobuf message TagGetReply
 */
export interface TagGetReply {
    /**
     * @generated from protobuf field: repeated TagGetReply.Tag tags = 1;
     */
    tags: TagGetReply_Tag[];
}
/**
 * @generated from protobuf message TagGetReply.Tag
 */
export interface TagGetReply_Tag {
    /**
     * @generated from protobuf field: string tag_id = 1;
     */
    tagId: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: TagModel.EntityType entity_type = 3;
     */
    entityType: TagModel_EntityType;
    /**
     * @generated from protobuf field: optional string text_color = 4;
     */
    textColor?: string;
    /**
     * @generated from protobuf field: optional string background_color = 5;
     */
    backgroundColor?: string;
}
/**
 * @generated from protobuf message TagAssignRequest
 */
export interface TagAssignRequest {
    /**
     * @generated from protobuf field: repeated string tag_ids = 1;
     */
    tagIds: string[];
    /**
     * @generated from protobuf field: string entity_id = 2;
     */
    entityId: string;
    /**
     * @generated from protobuf field: TagModel.EntityType entity_type = 3;
     */
    entityType: TagModel_EntityType;
}
/**
 * @generated from protobuf message TagAssignReply
 */
export interface TagAssignReply {
}
/**
 * @generated from protobuf message TagUnassignRequest
 */
export interface TagUnassignRequest {
    /**
     * @generated from protobuf field: repeated string tag_ids = 1;
     */
    tagIds: string[];
    /**
     * @generated from protobuf field: string entity_id = 2;
     */
    entityId: string;
    /**
     * @generated from protobuf field: TagModel.EntityType entity_type = 3;
     */
    entityType: TagModel_EntityType;
}
/**
 * @generated from protobuf message TagUnassignReply
 */
export interface TagUnassignReply {
}
/**
 * @generated from protobuf message TagEntityGetRequest
 */
export interface TagEntityGetRequest {
    /**
     * @generated from protobuf field: string entity_id = 1;
     */
    entityId: string;
    /**
     * @generated from protobuf field: TagModel.EntityType entity_type = 2;
     */
    entityType: TagModel_EntityType;
}
/**
 * @generated from protobuf message TagEntityGetReply
 */
export interface TagEntityGetReply {
    /**
     * @generated from protobuf field: repeated TagEntityGetReply.Tag tags = 1;
     */
    tags: TagEntityGetReply_Tag[];
}
/**
 * @generated from protobuf message TagEntityGetReply.Tag
 */
export interface TagEntityGetReply_Tag {
    /**
     * @generated from protobuf field: string tag_id = 1;
     */
    tagId: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: optional string text_color = 4;
     */
    textColor?: string;
    /**
     * @generated from protobuf field: optional string background_color = 5;
     */
    backgroundColor?: string;
}
/**
 * @generated from protobuf message TagEntityUpdateRequest
 */
export interface TagEntityUpdateRequest {
    /**
     * @generated from protobuf field: string entity_id = 1;
     */
    entityId: string;
    /**
     * @generated from protobuf field: TagModel.EntityType entity_type = 2;
     */
    entityType: TagModel_EntityType;
    /**
     * @generated from protobuf field: repeated string tag_ids = 3;
     */
    tagIds: string[];
}
/**
 * @generated from protobuf message TagEntityUpdateReply
 */
export interface TagEntityUpdateReply {
}
// @generated message type with reflection information, may provide speed optimized methods
class TagCreateRequest$Type extends MessageType<TagCreateRequest> {
    constructor() {
        super("TagCreateRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "entity_type", kind: "enum", T: () => ["TagModel.EntityType", TagModel_EntityType, "ENTITY_TYPE_"] },
            { no: 3, name: "text_color", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "background_color", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TagCreateRequest>): TagCreateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.entityType = 0;
        if (value !== undefined)
            reflectionMergePartial<TagCreateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TagCreateRequest): TagCreateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* TagModel.EntityType entity_type */ 2:
                    message.entityType = reader.int32();
                    break;
                case /* optional string text_color */ 3:
                    message.textColor = reader.string();
                    break;
                case /* optional string background_color */ 4:
                    message.backgroundColor = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TagCreateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* TagModel.EntityType entity_type = 2; */
        if (message.entityType !== 0)
            writer.tag(2, WireType.Varint).int32(message.entityType);
        /* optional string text_color = 3; */
        if (message.textColor !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.textColor);
        /* optional string background_color = 4; */
        if (message.backgroundColor !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.backgroundColor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TagCreateRequest
 */
export const TagCreateRequest = new TagCreateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TagCreateReply$Type extends MessageType<TagCreateReply> {
    constructor() {
        super("TagCreateReply", [
            { no: 1, name: "tag_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TagCreateReply>): TagCreateReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tagId = "";
        if (value !== undefined)
            reflectionMergePartial<TagCreateReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TagCreateReply): TagCreateReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tag_id */ 1:
                    message.tagId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TagCreateReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tag_id = 1; */
        if (message.tagId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tagId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TagCreateReply
 */
export const TagCreateReply = new TagCreateReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TagDeleteRequest$Type extends MessageType<TagDeleteRequest> {
    constructor() {
        super("TagDeleteRequest", [
            { no: 1, name: "tag_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TagDeleteRequest>): TagDeleteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tagId = "";
        if (value !== undefined)
            reflectionMergePartial<TagDeleteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TagDeleteRequest): TagDeleteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tag_id */ 1:
                    message.tagId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TagDeleteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tag_id = 1; */
        if (message.tagId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tagId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TagDeleteRequest
 */
export const TagDeleteRequest = new TagDeleteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TagDeleteReply$Type extends MessageType<TagDeleteReply> {
    constructor() {
        super("TagDeleteReply", []);
    }
    create(value?: PartialMessage<TagDeleteReply>): TagDeleteReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TagDeleteReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TagDeleteReply): TagDeleteReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: TagDeleteReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TagDeleteReply
 */
export const TagDeleteReply = new TagDeleteReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TagGetRequest$Type extends MessageType<TagGetRequest> {
    constructor() {
        super("TagGetRequest", []);
    }
    create(value?: PartialMessage<TagGetRequest>): TagGetRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TagGetRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TagGetRequest): TagGetRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: TagGetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TagGetRequest
 */
export const TagGetRequest = new TagGetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TagGetReply$Type extends MessageType<TagGetReply> {
    constructor() {
        super("TagGetReply", [
            { no: 1, name: "tags", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TagGetReply_Tag }
        ]);
    }
    create(value?: PartialMessage<TagGetReply>): TagGetReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tags = [];
        if (value !== undefined)
            reflectionMergePartial<TagGetReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TagGetReply): TagGetReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TagGetReply.Tag tags */ 1:
                    message.tags.push(TagGetReply_Tag.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TagGetReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated TagGetReply.Tag tags = 1; */
        for (let i = 0; i < message.tags.length; i++)
            TagGetReply_Tag.internalBinaryWrite(message.tags[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TagGetReply
 */
export const TagGetReply = new TagGetReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TagGetReply_Tag$Type extends MessageType<TagGetReply_Tag> {
    constructor() {
        super("TagGetReply.Tag", [
            { no: 1, name: "tag_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "entity_type", kind: "enum", T: () => ["TagModel.EntityType", TagModel_EntityType, "ENTITY_TYPE_"] },
            { no: 4, name: "text_color", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "background_color", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TagGetReply_Tag>): TagGetReply_Tag {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tagId = "";
        message.name = "";
        message.entityType = 0;
        if (value !== undefined)
            reflectionMergePartial<TagGetReply_Tag>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TagGetReply_Tag): TagGetReply_Tag {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tag_id */ 1:
                    message.tagId = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* TagModel.EntityType entity_type */ 3:
                    message.entityType = reader.int32();
                    break;
                case /* optional string text_color */ 4:
                    message.textColor = reader.string();
                    break;
                case /* optional string background_color */ 5:
                    message.backgroundColor = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TagGetReply_Tag, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tag_id = 1; */
        if (message.tagId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tagId);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* TagModel.EntityType entity_type = 3; */
        if (message.entityType !== 0)
            writer.tag(3, WireType.Varint).int32(message.entityType);
        /* optional string text_color = 4; */
        if (message.textColor !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.textColor);
        /* optional string background_color = 5; */
        if (message.backgroundColor !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.backgroundColor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TagGetReply.Tag
 */
export const TagGetReply_Tag = new TagGetReply_Tag$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TagAssignRequest$Type extends MessageType<TagAssignRequest> {
    constructor() {
        super("TagAssignRequest", [
            { no: 1, name: "tag_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "entity_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "entity_type", kind: "enum", T: () => ["TagModel.EntityType", TagModel_EntityType, "ENTITY_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<TagAssignRequest>): TagAssignRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tagIds = [];
        message.entityId = "";
        message.entityType = 0;
        if (value !== undefined)
            reflectionMergePartial<TagAssignRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TagAssignRequest): TagAssignRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string tag_ids */ 1:
                    message.tagIds.push(reader.string());
                    break;
                case /* string entity_id */ 2:
                    message.entityId = reader.string();
                    break;
                case /* TagModel.EntityType entity_type */ 3:
                    message.entityType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TagAssignRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string tag_ids = 1; */
        for (let i = 0; i < message.tagIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.tagIds[i]);
        /* string entity_id = 2; */
        if (message.entityId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.entityId);
        /* TagModel.EntityType entity_type = 3; */
        if (message.entityType !== 0)
            writer.tag(3, WireType.Varint).int32(message.entityType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TagAssignRequest
 */
export const TagAssignRequest = new TagAssignRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TagAssignReply$Type extends MessageType<TagAssignReply> {
    constructor() {
        super("TagAssignReply", []);
    }
    create(value?: PartialMessage<TagAssignReply>): TagAssignReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TagAssignReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TagAssignReply): TagAssignReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: TagAssignReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TagAssignReply
 */
export const TagAssignReply = new TagAssignReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TagUnassignRequest$Type extends MessageType<TagUnassignRequest> {
    constructor() {
        super("TagUnassignRequest", [
            { no: 1, name: "tag_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "entity_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "entity_type", kind: "enum", T: () => ["TagModel.EntityType", TagModel_EntityType, "ENTITY_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<TagUnassignRequest>): TagUnassignRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tagIds = [];
        message.entityId = "";
        message.entityType = 0;
        if (value !== undefined)
            reflectionMergePartial<TagUnassignRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TagUnassignRequest): TagUnassignRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string tag_ids */ 1:
                    message.tagIds.push(reader.string());
                    break;
                case /* string entity_id */ 2:
                    message.entityId = reader.string();
                    break;
                case /* TagModel.EntityType entity_type */ 3:
                    message.entityType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TagUnassignRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string tag_ids = 1; */
        for (let i = 0; i < message.tagIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.tagIds[i]);
        /* string entity_id = 2; */
        if (message.entityId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.entityId);
        /* TagModel.EntityType entity_type = 3; */
        if (message.entityType !== 0)
            writer.tag(3, WireType.Varint).int32(message.entityType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TagUnassignRequest
 */
export const TagUnassignRequest = new TagUnassignRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TagUnassignReply$Type extends MessageType<TagUnassignReply> {
    constructor() {
        super("TagUnassignReply", []);
    }
    create(value?: PartialMessage<TagUnassignReply>): TagUnassignReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TagUnassignReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TagUnassignReply): TagUnassignReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: TagUnassignReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TagUnassignReply
 */
export const TagUnassignReply = new TagUnassignReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TagEntityGetRequest$Type extends MessageType<TagEntityGetRequest> {
    constructor() {
        super("TagEntityGetRequest", [
            { no: 1, name: "entity_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "entity_type", kind: "enum", T: () => ["TagModel.EntityType", TagModel_EntityType, "ENTITY_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<TagEntityGetRequest>): TagEntityGetRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entityId = "";
        message.entityType = 0;
        if (value !== undefined)
            reflectionMergePartial<TagEntityGetRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TagEntityGetRequest): TagEntityGetRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string entity_id */ 1:
                    message.entityId = reader.string();
                    break;
                case /* TagModel.EntityType entity_type */ 2:
                    message.entityType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TagEntityGetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string entity_id = 1; */
        if (message.entityId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.entityId);
        /* TagModel.EntityType entity_type = 2; */
        if (message.entityType !== 0)
            writer.tag(2, WireType.Varint).int32(message.entityType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TagEntityGetRequest
 */
export const TagEntityGetRequest = new TagEntityGetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TagEntityGetReply$Type extends MessageType<TagEntityGetReply> {
    constructor() {
        super("TagEntityGetReply", [
            { no: 1, name: "tags", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TagEntityGetReply_Tag }
        ]);
    }
    create(value?: PartialMessage<TagEntityGetReply>): TagEntityGetReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tags = [];
        if (value !== undefined)
            reflectionMergePartial<TagEntityGetReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TagEntityGetReply): TagEntityGetReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TagEntityGetReply.Tag tags */ 1:
                    message.tags.push(TagEntityGetReply_Tag.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TagEntityGetReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated TagEntityGetReply.Tag tags = 1; */
        for (let i = 0; i < message.tags.length; i++)
            TagEntityGetReply_Tag.internalBinaryWrite(message.tags[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TagEntityGetReply
 */
export const TagEntityGetReply = new TagEntityGetReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TagEntityGetReply_Tag$Type extends MessageType<TagEntityGetReply_Tag> {
    constructor() {
        super("TagEntityGetReply.Tag", [
            { no: 1, name: "tag_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "text_color", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "background_color", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TagEntityGetReply_Tag>): TagEntityGetReply_Tag {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tagId = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<TagEntityGetReply_Tag>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TagEntityGetReply_Tag): TagEntityGetReply_Tag {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tag_id */ 1:
                    message.tagId = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* optional string text_color */ 4:
                    message.textColor = reader.string();
                    break;
                case /* optional string background_color */ 5:
                    message.backgroundColor = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TagEntityGetReply_Tag, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tag_id = 1; */
        if (message.tagId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tagId);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* optional string text_color = 4; */
        if (message.textColor !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.textColor);
        /* optional string background_color = 5; */
        if (message.backgroundColor !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.backgroundColor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TagEntityGetReply.Tag
 */
export const TagEntityGetReply_Tag = new TagEntityGetReply_Tag$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TagEntityUpdateRequest$Type extends MessageType<TagEntityUpdateRequest> {
    constructor() {
        super("TagEntityUpdateRequest", [
            { no: 1, name: "entity_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "entity_type", kind: "enum", T: () => ["TagModel.EntityType", TagModel_EntityType, "ENTITY_TYPE_"] },
            { no: 3, name: "tag_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TagEntityUpdateRequest>): TagEntityUpdateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entityId = "";
        message.entityType = 0;
        message.tagIds = [];
        if (value !== undefined)
            reflectionMergePartial<TagEntityUpdateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TagEntityUpdateRequest): TagEntityUpdateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string entity_id */ 1:
                    message.entityId = reader.string();
                    break;
                case /* TagModel.EntityType entity_type */ 2:
                    message.entityType = reader.int32();
                    break;
                case /* repeated string tag_ids */ 3:
                    message.tagIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TagEntityUpdateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string entity_id = 1; */
        if (message.entityId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.entityId);
        /* TagModel.EntityType entity_type = 2; */
        if (message.entityType !== 0)
            writer.tag(2, WireType.Varint).int32(message.entityType);
        /* repeated string tag_ids = 3; */
        for (let i = 0; i < message.tagIds.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.tagIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TagEntityUpdateRequest
 */
export const TagEntityUpdateRequest = new TagEntityUpdateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TagEntityUpdateReply$Type extends MessageType<TagEntityUpdateReply> {
    constructor() {
        super("TagEntityUpdateReply", []);
    }
    create(value?: PartialMessage<TagEntityUpdateReply>): TagEntityUpdateReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TagEntityUpdateReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TagEntityUpdateReply): TagEntityUpdateReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: TagEntityUpdateReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TagEntityUpdateReply
 */
export const TagEntityUpdateReply = new TagEntityUpdateReply$Type();
/**
 * @generated ServiceType for protobuf service TagService
 */
export const TagService = new ServiceType("TagService", [
    { name: "TagCreate", options: {}, I: TagCreateRequest, O: TagCreateReply },
    { name: "TagDelete", options: {}, I: TagDeleteRequest, O: TagDeleteReply },
    { name: "TagGet", options: {}, I: TagGetRequest, O: TagGetReply },
    { name: "TagEntityGet", options: {}, I: TagEntityGetRequest, O: TagEntityGetReply },
    { name: "TagEntityUpdate", options: {}, I: TagEntityUpdateRequest, O: TagEntityUpdateReply },
    { name: "TagAssign", options: {}, I: TagAssignRequest, O: TagAssignReply },
    { name: "TagUnassign", options: {}, I: TagUnassignRequest, O: TagUnassignReply }
]);
