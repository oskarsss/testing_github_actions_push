// @generated by protobuf-ts 2.9.4 with parameter long_type_number,generate_dependencies,ts_nocheck,output_typescript
// @generated from protobuf file "v1/trucks_availability.proto" (syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { TruckModel_Availability_EmptyAtType } from "./models/model_truck";
/**
 * @generated from protobuf message GetTrucksAvailabilityRequest
 */
export interface GetTrucksAvailabilityRequest {
}
/**
 * @generated from protobuf message GetTrucksAvailabilityReply
 */
export interface GetTrucksAvailabilityReply {
    /**
     * @generated from protobuf field: repeated GetTrucksAvailabilityReply.TruckAvailability trucks_availability = 1;
     */
    trucksAvailability: GetTrucksAvailabilityReply_TruckAvailability[];
}
/**
 * @generated from protobuf message GetTrucksAvailabilityReply.TruckAvailability
 */
export interface GetTrucksAvailabilityReply_TruckAvailability {
    /**
     * @generated from protobuf field: string truck_id = 1;
     */
    truckId: string;
    /**
     * @generated from protobuf field: bool is_team = 2;
     */
    isTeam: boolean;
    /**
     * @generated from protobuf field: string empty_at = 3;
     */
    emptyAt: string;
    /**
     * @generated from protobuf field: TruckModel.Availability.EmptyAtType empty_at_type = 4;
     */
    emptyAtType: TruckModel_Availability_EmptyAtType;
    /**
     * @generated from protobuf field: GetTrucksAvailabilityReply.TruckAvailability.DropoffLocation dropoff_location = 5;
     */
    dropoffLocation?: GetTrucksAvailabilityReply_TruckAvailability_DropoffLocation;
    /**
     * @generated from protobuf field: string note = 6;
     */
    note: string;
}
/**
 * @generated from protobuf message GetTrucksAvailabilityReply.TruckAvailability.DropoffLocation
 */
export interface GetTrucksAvailabilityReply_TruckAvailability_DropoffLocation {
    /**
     * @generated from protobuf field: string city = 1;
     */
    city: string;
    /**
     * @generated from protobuf field: string state = 2;
     */
    state: string;
    /**
     * @generated from protobuf field: float lat = 3;
     */
    lat: number;
    /**
     * @generated from protobuf field: float lon = 4;
     */
    lon: number;
}
/**
 * Update Truck Availability
 *
 * @generated from protobuf message UpdateTruckAvailabilityRequest
 */
export interface UpdateTruckAvailabilityRequest {
    /**
     * @generated from protobuf field: string truck_id = 1;
     */
    truckId: string;
    /**
     * @generated from protobuf field: string note = 2;
     */
    note: string;
    /**
     * @generated from protobuf field: bool auto_post = 3;
     */
    autoPost: boolean;
}
/**
 * @generated from protobuf message UpdateTruckAvailabilityReply
 */
export interface UpdateTruckAvailabilityReply {
}
/**
 * Set Online
 *
 * @generated from protobuf message TruckAvailabilitySetOnlineRequest
 */
export interface TruckAvailabilitySetOnlineRequest {
    /**
     * @generated from protobuf field: string truck_id = 1;
     */
    truckId: string;
}
/**
 * @generated from protobuf message TruckAvailabilitySetOnlineReply
 */
export interface TruckAvailabilitySetOnlineReply {
}
/**
 * Set Offline
 *
 * @generated from protobuf message TruckAvailabilitySetOfflineRequest
 */
export interface TruckAvailabilitySetOfflineRequest {
    /**
     * @generated from protobuf field: string truck_id = 1;
     */
    truckId: string;
}
/**
 * @generated from protobuf message TruckAvailabilitySetOfflineReply
 */
export interface TruckAvailabilitySetOfflineReply {
}
/**
 * Trucks share capacity
 *
 * @generated from protobuf message LinkCreateRequest
 */
export interface LinkCreateRequest {
}
/**
 * @generated from protobuf message LinkCreateReply
 */
export interface LinkCreateReply {
    /**
     * @generated from protobuf field: string token = 1;
     */
    token: string;
}
/**
 * @generated from protobuf message LinkRevokeRequest
 */
export interface LinkRevokeRequest {
    /**
     * @generated from protobuf field: string token = 1;
     */
    token: string;
}
/**
 * @generated from protobuf message LinkRevokeReply
 */
export interface LinkRevokeReply {
}
/**
 * @generated from protobuf message LinkGetRequest
 */
export interface LinkGetRequest {
}
/**
 * @generated from protobuf message LinkGetReply
 */
export interface LinkGetReply {
    /**
     * @generated from protobuf field: string token = 1;
     */
    token: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class GetTrucksAvailabilityRequest$Type extends MessageType<GetTrucksAvailabilityRequest> {
    constructor() {
        super("GetTrucksAvailabilityRequest", []);
    }
    create(value?: PartialMessage<GetTrucksAvailabilityRequest>): GetTrucksAvailabilityRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetTrucksAvailabilityRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTrucksAvailabilityRequest): GetTrucksAvailabilityRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetTrucksAvailabilityRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetTrucksAvailabilityRequest
 */
export const GetTrucksAvailabilityRequest = new GetTrucksAvailabilityRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTrucksAvailabilityReply$Type extends MessageType<GetTrucksAvailabilityReply> {
    constructor() {
        super("GetTrucksAvailabilityReply", [
            { no: 1, name: "trucks_availability", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GetTrucksAvailabilityReply_TruckAvailability }
        ]);
    }
    create(value?: PartialMessage<GetTrucksAvailabilityReply>): GetTrucksAvailabilityReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.trucksAvailability = [];
        if (value !== undefined)
            reflectionMergePartial<GetTrucksAvailabilityReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTrucksAvailabilityReply): GetTrucksAvailabilityReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated GetTrucksAvailabilityReply.TruckAvailability trucks_availability */ 1:
                    message.trucksAvailability.push(GetTrucksAvailabilityReply_TruckAvailability.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTrucksAvailabilityReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated GetTrucksAvailabilityReply.TruckAvailability trucks_availability = 1; */
        for (let i = 0; i < message.trucksAvailability.length; i++)
            GetTrucksAvailabilityReply_TruckAvailability.internalBinaryWrite(message.trucksAvailability[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetTrucksAvailabilityReply
 */
export const GetTrucksAvailabilityReply = new GetTrucksAvailabilityReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTrucksAvailabilityReply_TruckAvailability$Type extends MessageType<GetTrucksAvailabilityReply_TruckAvailability> {
    constructor() {
        super("GetTrucksAvailabilityReply.TruckAvailability", [
            { no: 1, name: "truck_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "is_team", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "empty_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "empty_at_type", kind: "enum", T: () => ["TruckModel.Availability.EmptyAtType", TruckModel_Availability_EmptyAtType] },
            { no: 5, name: "dropoff_location", kind: "message", T: () => GetTrucksAvailabilityReply_TruckAvailability_DropoffLocation },
            { no: 6, name: "note", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetTrucksAvailabilityReply_TruckAvailability>): GetTrucksAvailabilityReply_TruckAvailability {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.truckId = "";
        message.isTeam = false;
        message.emptyAt = "";
        message.emptyAtType = 0;
        message.note = "";
        if (value !== undefined)
            reflectionMergePartial<GetTrucksAvailabilityReply_TruckAvailability>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTrucksAvailabilityReply_TruckAvailability): GetTrucksAvailabilityReply_TruckAvailability {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string truck_id */ 1:
                    message.truckId = reader.string();
                    break;
                case /* bool is_team */ 2:
                    message.isTeam = reader.bool();
                    break;
                case /* string empty_at */ 3:
                    message.emptyAt = reader.string();
                    break;
                case /* TruckModel.Availability.EmptyAtType empty_at_type */ 4:
                    message.emptyAtType = reader.int32();
                    break;
                case /* GetTrucksAvailabilityReply.TruckAvailability.DropoffLocation dropoff_location */ 5:
                    message.dropoffLocation = GetTrucksAvailabilityReply_TruckAvailability_DropoffLocation.internalBinaryRead(reader, reader.uint32(), options, message.dropoffLocation);
                    break;
                case /* string note */ 6:
                    message.note = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTrucksAvailabilityReply_TruckAvailability, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string truck_id = 1; */
        if (message.truckId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.truckId);
        /* bool is_team = 2; */
        if (message.isTeam !== false)
            writer.tag(2, WireType.Varint).bool(message.isTeam);
        /* string empty_at = 3; */
        if (message.emptyAt !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.emptyAt);
        /* TruckModel.Availability.EmptyAtType empty_at_type = 4; */
        if (message.emptyAtType !== 0)
            writer.tag(4, WireType.Varint).int32(message.emptyAtType);
        /* GetTrucksAvailabilityReply.TruckAvailability.DropoffLocation dropoff_location = 5; */
        if (message.dropoffLocation)
            GetTrucksAvailabilityReply_TruckAvailability_DropoffLocation.internalBinaryWrite(message.dropoffLocation, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string note = 6; */
        if (message.note !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.note);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetTrucksAvailabilityReply.TruckAvailability
 */
export const GetTrucksAvailabilityReply_TruckAvailability = new GetTrucksAvailabilityReply_TruckAvailability$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTrucksAvailabilityReply_TruckAvailability_DropoffLocation$Type extends MessageType<GetTrucksAvailabilityReply_TruckAvailability_DropoffLocation> {
    constructor() {
        super("GetTrucksAvailabilityReply.TruckAvailability.DropoffLocation", [
            { no: 1, name: "city", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "lat", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "lon", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<GetTrucksAvailabilityReply_TruckAvailability_DropoffLocation>): GetTrucksAvailabilityReply_TruckAvailability_DropoffLocation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.city = "";
        message.state = "";
        message.lat = 0;
        message.lon = 0;
        if (value !== undefined)
            reflectionMergePartial<GetTrucksAvailabilityReply_TruckAvailability_DropoffLocation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTrucksAvailabilityReply_TruckAvailability_DropoffLocation): GetTrucksAvailabilityReply_TruckAvailability_DropoffLocation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string city */ 1:
                    message.city = reader.string();
                    break;
                case /* string state */ 2:
                    message.state = reader.string();
                    break;
                case /* float lat */ 3:
                    message.lat = reader.float();
                    break;
                case /* float lon */ 4:
                    message.lon = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTrucksAvailabilityReply_TruckAvailability_DropoffLocation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string city = 1; */
        if (message.city !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.city);
        /* string state = 2; */
        if (message.state !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.state);
        /* float lat = 3; */
        if (message.lat !== 0)
            writer.tag(3, WireType.Bit32).float(message.lat);
        /* float lon = 4; */
        if (message.lon !== 0)
            writer.tag(4, WireType.Bit32).float(message.lon);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetTrucksAvailabilityReply.TruckAvailability.DropoffLocation
 */
export const GetTrucksAvailabilityReply_TruckAvailability_DropoffLocation = new GetTrucksAvailabilityReply_TruckAvailability_DropoffLocation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateTruckAvailabilityRequest$Type extends MessageType<UpdateTruckAvailabilityRequest> {
    constructor() {
        super("UpdateTruckAvailabilityRequest", [
            { no: 1, name: "truck_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "note", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "auto_post", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateTruckAvailabilityRequest>): UpdateTruckAvailabilityRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.truckId = "";
        message.note = "";
        message.autoPost = false;
        if (value !== undefined)
            reflectionMergePartial<UpdateTruckAvailabilityRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateTruckAvailabilityRequest): UpdateTruckAvailabilityRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string truck_id */ 1:
                    message.truckId = reader.string();
                    break;
                case /* string note */ 2:
                    message.note = reader.string();
                    break;
                case /* bool auto_post */ 3:
                    message.autoPost = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateTruckAvailabilityRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string truck_id = 1; */
        if (message.truckId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.truckId);
        /* string note = 2; */
        if (message.note !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.note);
        /* bool auto_post = 3; */
        if (message.autoPost !== false)
            writer.tag(3, WireType.Varint).bool(message.autoPost);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdateTruckAvailabilityRequest
 */
export const UpdateTruckAvailabilityRequest = new UpdateTruckAvailabilityRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateTruckAvailabilityReply$Type extends MessageType<UpdateTruckAvailabilityReply> {
    constructor() {
        super("UpdateTruckAvailabilityReply", []);
    }
    create(value?: PartialMessage<UpdateTruckAvailabilityReply>): UpdateTruckAvailabilityReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateTruckAvailabilityReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateTruckAvailabilityReply): UpdateTruckAvailabilityReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: UpdateTruckAvailabilityReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdateTruckAvailabilityReply
 */
export const UpdateTruckAvailabilityReply = new UpdateTruckAvailabilityReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TruckAvailabilitySetOnlineRequest$Type extends MessageType<TruckAvailabilitySetOnlineRequest> {
    constructor() {
        super("TruckAvailabilitySetOnlineRequest", [
            { no: 1, name: "truck_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TruckAvailabilitySetOnlineRequest>): TruckAvailabilitySetOnlineRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.truckId = "";
        if (value !== undefined)
            reflectionMergePartial<TruckAvailabilitySetOnlineRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TruckAvailabilitySetOnlineRequest): TruckAvailabilitySetOnlineRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string truck_id */ 1:
                    message.truckId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TruckAvailabilitySetOnlineRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string truck_id = 1; */
        if (message.truckId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.truckId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TruckAvailabilitySetOnlineRequest
 */
export const TruckAvailabilitySetOnlineRequest = new TruckAvailabilitySetOnlineRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TruckAvailabilitySetOnlineReply$Type extends MessageType<TruckAvailabilitySetOnlineReply> {
    constructor() {
        super("TruckAvailabilitySetOnlineReply", []);
    }
    create(value?: PartialMessage<TruckAvailabilitySetOnlineReply>): TruckAvailabilitySetOnlineReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TruckAvailabilitySetOnlineReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TruckAvailabilitySetOnlineReply): TruckAvailabilitySetOnlineReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: TruckAvailabilitySetOnlineReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TruckAvailabilitySetOnlineReply
 */
export const TruckAvailabilitySetOnlineReply = new TruckAvailabilitySetOnlineReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TruckAvailabilitySetOfflineRequest$Type extends MessageType<TruckAvailabilitySetOfflineRequest> {
    constructor() {
        super("TruckAvailabilitySetOfflineRequest", [
            { no: 1, name: "truck_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TruckAvailabilitySetOfflineRequest>): TruckAvailabilitySetOfflineRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.truckId = "";
        if (value !== undefined)
            reflectionMergePartial<TruckAvailabilitySetOfflineRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TruckAvailabilitySetOfflineRequest): TruckAvailabilitySetOfflineRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string truck_id */ 1:
                    message.truckId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TruckAvailabilitySetOfflineRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string truck_id = 1; */
        if (message.truckId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.truckId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TruckAvailabilitySetOfflineRequest
 */
export const TruckAvailabilitySetOfflineRequest = new TruckAvailabilitySetOfflineRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TruckAvailabilitySetOfflineReply$Type extends MessageType<TruckAvailabilitySetOfflineReply> {
    constructor() {
        super("TruckAvailabilitySetOfflineReply", []);
    }
    create(value?: PartialMessage<TruckAvailabilitySetOfflineReply>): TruckAvailabilitySetOfflineReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TruckAvailabilitySetOfflineReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TruckAvailabilitySetOfflineReply): TruckAvailabilitySetOfflineReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: TruckAvailabilitySetOfflineReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TruckAvailabilitySetOfflineReply
 */
export const TruckAvailabilitySetOfflineReply = new TruckAvailabilitySetOfflineReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LinkCreateRequest$Type extends MessageType<LinkCreateRequest> {
    constructor() {
        super("LinkCreateRequest", []);
    }
    create(value?: PartialMessage<LinkCreateRequest>): LinkCreateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<LinkCreateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LinkCreateRequest): LinkCreateRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: LinkCreateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message LinkCreateRequest
 */
export const LinkCreateRequest = new LinkCreateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LinkCreateReply$Type extends MessageType<LinkCreateReply> {
    constructor() {
        super("LinkCreateReply", [
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LinkCreateReply>): LinkCreateReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<LinkCreateReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LinkCreateReply): LinkCreateReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LinkCreateReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message LinkCreateReply
 */
export const LinkCreateReply = new LinkCreateReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LinkRevokeRequest$Type extends MessageType<LinkRevokeRequest> {
    constructor() {
        super("LinkRevokeRequest", [
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LinkRevokeRequest>): LinkRevokeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<LinkRevokeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LinkRevokeRequest): LinkRevokeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LinkRevokeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message LinkRevokeRequest
 */
export const LinkRevokeRequest = new LinkRevokeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LinkRevokeReply$Type extends MessageType<LinkRevokeReply> {
    constructor() {
        super("LinkRevokeReply", []);
    }
    create(value?: PartialMessage<LinkRevokeReply>): LinkRevokeReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<LinkRevokeReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LinkRevokeReply): LinkRevokeReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: LinkRevokeReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message LinkRevokeReply
 */
export const LinkRevokeReply = new LinkRevokeReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LinkGetRequest$Type extends MessageType<LinkGetRequest> {
    constructor() {
        super("LinkGetRequest", []);
    }
    create(value?: PartialMessage<LinkGetRequest>): LinkGetRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<LinkGetRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LinkGetRequest): LinkGetRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: LinkGetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message LinkGetRequest
 */
export const LinkGetRequest = new LinkGetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LinkGetReply$Type extends MessageType<LinkGetReply> {
    constructor() {
        super("LinkGetReply", [
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LinkGetReply>): LinkGetReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<LinkGetReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LinkGetReply): LinkGetReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LinkGetReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message LinkGetReply
 */
export const LinkGetReply = new LinkGetReply$Type();
/**
 * @generated ServiceType for protobuf service TrucksAvailabilityService
 */
export const TrucksAvailabilityService = new ServiceType("TrucksAvailabilityService", [
    { name: "GetTrucksAvailability", options: {}, I: GetTrucksAvailabilityRequest, O: GetTrucksAvailabilityReply },
    { name: "UpdateTruckAvailability", options: {}, I: UpdateTruckAvailabilityRequest, O: UpdateTruckAvailabilityReply },
    { name: "TruckAvailabilitySetOnline", options: {}, I: TruckAvailabilitySetOnlineRequest, O: TruckAvailabilitySetOnlineReply },
    { name: "TruckAvailabilitySetOffline", options: {}, I: TruckAvailabilitySetOfflineRequest, O: TruckAvailabilitySetOfflineReply },
    { name: "LinkCreate", options: {}, I: LinkCreateRequest, O: LinkCreateReply },
    { name: "LinkRevoke", options: {}, I: LinkRevokeRequest, O: LinkRevokeReply },
    { name: "LinkGet", options: {}, I: LinkGetRequest, O: LinkGetReply }
]);
