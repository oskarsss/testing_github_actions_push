// @generated by protobuf-ts 2.9.4 with parameter long_type_number,generate_dependencies,ts_nocheck,output_typescript
// @generated from protobuf file "v1/settings_billing.proto" (syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Settings_Billing_Invoice_Status } from "./models/model_billing";
import { Settings_Billing_Status } from "./models/model_billing";
import { Settings_Billing_Card_Brand } from "./models/model_billing";
/**
 * @generated from protobuf message GetPaymentMethodRequest
 */
export interface GetPaymentMethodRequest {
}
/**
 * @generated from protobuf message GetPaymentMethodReply
 */
export interface GetPaymentMethodReply {
    /**
     * @generated from protobuf field: string card_last_four = 1;
     */
    cardLastFour: string;
    /**
     * @generated from protobuf field: Settings.Billing.Card.Brand card_brand = 2;
     */
    cardBrand: Settings_Billing_Card_Brand;
    /**
     * @generated from protobuf field: int64 card_exp_month = 3;
     */
    cardExpMonth: number;
    /**
     * @generated from protobuf field: int64 card_exp_year = 4;
     */
    cardExpYear: number;
}
/**
 * @generated from protobuf message GetSubscriptionRequest
 */
export interface GetSubscriptionRequest {
}
/**
 * @generated from protobuf message GetSubscriptionReply
 */
export interface GetSubscriptionReply {
    /**
     * @generated from protobuf field: Settings.Billing.Status subscription_status = 1;
     */
    subscriptionStatus: Settings_Billing_Status;
    /**
     * @generated from protobuf field: GetSubscriptionReply.FreeTrial free_trial = 2;
     */
    freeTrial?: GetSubscriptionReply_FreeTrial;
    /**
     * @generated from protobuf field: GetSubscriptionReply.Subscription subscription = 3;
     */
    subscription?: GetSubscriptionReply_Subscription;
    /**
     * @generated from protobuf field: int64 quantity = 4;
     */
    quantity: number;
}
/**
 * @generated from protobuf message GetSubscriptionReply.FreeTrial
 */
export interface GetSubscriptionReply_FreeTrial {
    /**
     * @generated from protobuf field: string start_date = 1;
     */
    startDate: string;
    /**
     * @generated from protobuf field: string end_date = 2;
     */
    endDate: string;
    /**
     * @generated from protobuf field: int32 days_left = 3;
     */
    daysLeft: number;
}
/**
 * @generated from protobuf message GetSubscriptionReply.Subscription
 */
export interface GetSubscriptionReply_Subscription {
    /**
     * @generated from protobuf field: string startDate = 1;
     */
    startDate: string;
    /**
     * @generated from protobuf field: string endDate = 2;
     */
    endDate: string;
    /**
     * @generated from protobuf field: GetSubscriptionReply.Subscription.UpcomingInvoice upcoming_invoice = 3;
     */
    upcomingInvoice?: GetSubscriptionReply_Subscription_UpcomingInvoice;
    /**
     * @generated from protobuf field: int64 current_tier_idx = 4;
     */
    currentTierIdx: number;
    /**
     * @generated from protobuf field: repeated GetSubscriptionReply.Subscription.Tier tiers = 5;
     */
    tiers: GetSubscriptionReply_Subscription_Tier[];
}
/**
 * @generated from protobuf message GetSubscriptionReply.Subscription.UpcomingInvoice
 */
export interface GetSubscriptionReply_Subscription_UpcomingInvoice {
    /**
     * @generated from protobuf field: string startDate = 1;
     */
    startDate: string;
    /**
     * @generated from protobuf field: string endDate = 2;
     */
    endDate: string;
    /**
     * @generated from protobuf field: string nextPaymentDate = 3;
     */
    nextPaymentDate: string;
    /**
     * @generated from protobuf field: string amountDue = 4;
     */
    amountDue: string;
    /**
     * @generated from protobuf field: string description = 5;
     */
    description: string;
    /**
     * @generated from protobuf field: int64 stripe_quantity = 6;
     */
    stripeQuantity: number;
}
/**
 * @generated from protobuf message GetSubscriptionReply.Subscription.Tier
 */
export interface GetSubscriptionReply_Subscription_Tier {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string price_per_truck_per_month = 2;
     */
    pricePerTruckPerMonth: string;
    /**
     * @generated from protobuf field: int64 up_to_trucks = 3;
     */
    upToTrucks: number;
}
/**
 * @generated from protobuf message CheckoutRequest
 */
export interface CheckoutRequest {
}
/**
 * @generated from protobuf message CheckoutReply
 */
export interface CheckoutReply {
    /**
     * @generated from protobuf field: string session_url = 1;
     */
    sessionUrl: string;
}
/**
 * @generated from protobuf message GetInvoicesRequest
 */
export interface GetInvoicesRequest {
}
/**
 * @generated from protobuf message GetInvoicesReply
 */
export interface GetInvoicesReply {
    /**
     * @generated from protobuf field: repeated GetInvoicesReply.Invoice invoices = 1;
     */
    invoices: GetInvoicesReply_Invoice[];
}
/**
 * @generated from protobuf message GetInvoicesReply.Invoice
 */
export interface GetInvoicesReply_Invoice {
    /**
     * @generated from protobuf field: string amountDue = 1;
     */
    amountDue: string;
    /**
     * @generated from protobuf field: Settings.Billing.Invoice.Status status = 2;
     */
    status: Settings_Billing_Invoice_Status;
    /**
     * @generated from protobuf field: string number = 3;
     */
    number: string;
    /**
     * @generated from protobuf field: string hosted_invoice_url = 4;
     */
    hostedInvoiceUrl: string;
    /**
     * @generated from protobuf field: string invoice_pdf_url = 5;
     */
    invoicePdfUrl: string;
    /**
     * @generated from protobuf field: string period_start = 6;
     */
    periodStart: string;
    /**
     * @generated from protobuf field: string period_end = 7;
     */
    periodEnd: string;
    /**
     * @generated from protobuf field: string description = 8;
     */
    description: string;
}
/**
 * @generated from protobuf message CreateSessionRequest
 */
export interface CreateSessionRequest {
}
/**
 * @generated from protobuf message CreateSessionReply
 */
export interface CreateSessionReply {
    /**
     * @generated from protobuf field: string session_url = 1;
     */
    sessionUrl: string;
}
/**
 * @generated from protobuf message CancelAccountRequest
 */
export interface CancelAccountRequest {
}
/**
 * @generated from protobuf message CancelAccountReply
 */
export interface CancelAccountReply {
}
// @generated message type with reflection information, may provide speed optimized methods
class GetPaymentMethodRequest$Type extends MessageType<GetPaymentMethodRequest> {
    constructor() {
        super("GetPaymentMethodRequest", []);
    }
    create(value?: PartialMessage<GetPaymentMethodRequest>): GetPaymentMethodRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetPaymentMethodRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPaymentMethodRequest): GetPaymentMethodRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetPaymentMethodRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetPaymentMethodRequest
 */
export const GetPaymentMethodRequest = new GetPaymentMethodRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPaymentMethodReply$Type extends MessageType<GetPaymentMethodReply> {
    constructor() {
        super("GetPaymentMethodReply", [
            { no: 1, name: "card_last_four", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "card_brand", kind: "enum", T: () => ["Settings.Billing.Card.Brand", Settings_Billing_Card_Brand] },
            { no: 3, name: "card_exp_month", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "card_exp_year", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<GetPaymentMethodReply>): GetPaymentMethodReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cardLastFour = "";
        message.cardBrand = 0;
        message.cardExpMonth = 0;
        message.cardExpYear = 0;
        if (value !== undefined)
            reflectionMergePartial<GetPaymentMethodReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPaymentMethodReply): GetPaymentMethodReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string card_last_four */ 1:
                    message.cardLastFour = reader.string();
                    break;
                case /* Settings.Billing.Card.Brand card_brand */ 2:
                    message.cardBrand = reader.int32();
                    break;
                case /* int64 card_exp_month */ 3:
                    message.cardExpMonth = reader.int64().toNumber();
                    break;
                case /* int64 card_exp_year */ 4:
                    message.cardExpYear = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPaymentMethodReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string card_last_four = 1; */
        if (message.cardLastFour !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cardLastFour);
        /* Settings.Billing.Card.Brand card_brand = 2; */
        if (message.cardBrand !== 0)
            writer.tag(2, WireType.Varint).int32(message.cardBrand);
        /* int64 card_exp_month = 3; */
        if (message.cardExpMonth !== 0)
            writer.tag(3, WireType.Varint).int64(message.cardExpMonth);
        /* int64 card_exp_year = 4; */
        if (message.cardExpYear !== 0)
            writer.tag(4, WireType.Varint).int64(message.cardExpYear);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetPaymentMethodReply
 */
export const GetPaymentMethodReply = new GetPaymentMethodReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSubscriptionRequest$Type extends MessageType<GetSubscriptionRequest> {
    constructor() {
        super("GetSubscriptionRequest", []);
    }
    create(value?: PartialMessage<GetSubscriptionRequest>): GetSubscriptionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetSubscriptionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSubscriptionRequest): GetSubscriptionRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetSubscriptionRequest
 */
export const GetSubscriptionRequest = new GetSubscriptionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSubscriptionReply$Type extends MessageType<GetSubscriptionReply> {
    constructor() {
        super("GetSubscriptionReply", [
            { no: 1, name: "subscription_status", kind: "enum", T: () => ["Settings.Billing.Status", Settings_Billing_Status] },
            { no: 2, name: "free_trial", kind: "message", T: () => GetSubscriptionReply_FreeTrial },
            { no: 3, name: "subscription", kind: "message", T: () => GetSubscriptionReply_Subscription },
            { no: 4, name: "quantity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<GetSubscriptionReply>): GetSubscriptionReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscriptionStatus = 0;
        message.quantity = 0;
        if (value !== undefined)
            reflectionMergePartial<GetSubscriptionReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSubscriptionReply): GetSubscriptionReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Settings.Billing.Status subscription_status */ 1:
                    message.subscriptionStatus = reader.int32();
                    break;
                case /* GetSubscriptionReply.FreeTrial free_trial */ 2:
                    message.freeTrial = GetSubscriptionReply_FreeTrial.internalBinaryRead(reader, reader.uint32(), options, message.freeTrial);
                    break;
                case /* GetSubscriptionReply.Subscription subscription */ 3:
                    message.subscription = GetSubscriptionReply_Subscription.internalBinaryRead(reader, reader.uint32(), options, message.subscription);
                    break;
                case /* int64 quantity */ 4:
                    message.quantity = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSubscriptionReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Settings.Billing.Status subscription_status = 1; */
        if (message.subscriptionStatus !== 0)
            writer.tag(1, WireType.Varint).int32(message.subscriptionStatus);
        /* GetSubscriptionReply.FreeTrial free_trial = 2; */
        if (message.freeTrial)
            GetSubscriptionReply_FreeTrial.internalBinaryWrite(message.freeTrial, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* GetSubscriptionReply.Subscription subscription = 3; */
        if (message.subscription)
            GetSubscriptionReply_Subscription.internalBinaryWrite(message.subscription, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* int64 quantity = 4; */
        if (message.quantity !== 0)
            writer.tag(4, WireType.Varint).int64(message.quantity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetSubscriptionReply
 */
export const GetSubscriptionReply = new GetSubscriptionReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSubscriptionReply_FreeTrial$Type extends MessageType<GetSubscriptionReply_FreeTrial> {
    constructor() {
        super("GetSubscriptionReply.FreeTrial", [
            { no: 1, name: "start_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "end_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "days_left", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetSubscriptionReply_FreeTrial>): GetSubscriptionReply_FreeTrial {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.startDate = "";
        message.endDate = "";
        message.daysLeft = 0;
        if (value !== undefined)
            reflectionMergePartial<GetSubscriptionReply_FreeTrial>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSubscriptionReply_FreeTrial): GetSubscriptionReply_FreeTrial {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string start_date */ 1:
                    message.startDate = reader.string();
                    break;
                case /* string end_date */ 2:
                    message.endDate = reader.string();
                    break;
                case /* int32 days_left */ 3:
                    message.daysLeft = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSubscriptionReply_FreeTrial, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string start_date = 1; */
        if (message.startDate !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.startDate);
        /* string end_date = 2; */
        if (message.endDate !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.endDate);
        /* int32 days_left = 3; */
        if (message.daysLeft !== 0)
            writer.tag(3, WireType.Varint).int32(message.daysLeft);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetSubscriptionReply.FreeTrial
 */
export const GetSubscriptionReply_FreeTrial = new GetSubscriptionReply_FreeTrial$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSubscriptionReply_Subscription$Type extends MessageType<GetSubscriptionReply_Subscription> {
    constructor() {
        super("GetSubscriptionReply.Subscription", [
            { no: 1, name: "startDate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "endDate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "upcoming_invoice", kind: "message", T: () => GetSubscriptionReply_Subscription_UpcomingInvoice },
            { no: 4, name: "current_tier_idx", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 5, name: "tiers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GetSubscriptionReply_Subscription_Tier }
        ]);
    }
    create(value?: PartialMessage<GetSubscriptionReply_Subscription>): GetSubscriptionReply_Subscription {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.startDate = "";
        message.endDate = "";
        message.currentTierIdx = 0;
        message.tiers = [];
        if (value !== undefined)
            reflectionMergePartial<GetSubscriptionReply_Subscription>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSubscriptionReply_Subscription): GetSubscriptionReply_Subscription {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string startDate */ 1:
                    message.startDate = reader.string();
                    break;
                case /* string endDate */ 2:
                    message.endDate = reader.string();
                    break;
                case /* GetSubscriptionReply.Subscription.UpcomingInvoice upcoming_invoice */ 3:
                    message.upcomingInvoice = GetSubscriptionReply_Subscription_UpcomingInvoice.internalBinaryRead(reader, reader.uint32(), options, message.upcomingInvoice);
                    break;
                case /* int64 current_tier_idx */ 4:
                    message.currentTierIdx = reader.int64().toNumber();
                    break;
                case /* repeated GetSubscriptionReply.Subscription.Tier tiers */ 5:
                    message.tiers.push(GetSubscriptionReply_Subscription_Tier.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSubscriptionReply_Subscription, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string startDate = 1; */
        if (message.startDate !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.startDate);
        /* string endDate = 2; */
        if (message.endDate !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.endDate);
        /* GetSubscriptionReply.Subscription.UpcomingInvoice upcoming_invoice = 3; */
        if (message.upcomingInvoice)
            GetSubscriptionReply_Subscription_UpcomingInvoice.internalBinaryWrite(message.upcomingInvoice, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* int64 current_tier_idx = 4; */
        if (message.currentTierIdx !== 0)
            writer.tag(4, WireType.Varint).int64(message.currentTierIdx);
        /* repeated GetSubscriptionReply.Subscription.Tier tiers = 5; */
        for (let i = 0; i < message.tiers.length; i++)
            GetSubscriptionReply_Subscription_Tier.internalBinaryWrite(message.tiers[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetSubscriptionReply.Subscription
 */
export const GetSubscriptionReply_Subscription = new GetSubscriptionReply_Subscription$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSubscriptionReply_Subscription_UpcomingInvoice$Type extends MessageType<GetSubscriptionReply_Subscription_UpcomingInvoice> {
    constructor() {
        super("GetSubscriptionReply.Subscription.UpcomingInvoice", [
            { no: 1, name: "startDate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "endDate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "nextPaymentDate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "amountDue", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "stripe_quantity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<GetSubscriptionReply_Subscription_UpcomingInvoice>): GetSubscriptionReply_Subscription_UpcomingInvoice {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.startDate = "";
        message.endDate = "";
        message.nextPaymentDate = "";
        message.amountDue = "";
        message.description = "";
        message.stripeQuantity = 0;
        if (value !== undefined)
            reflectionMergePartial<GetSubscriptionReply_Subscription_UpcomingInvoice>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSubscriptionReply_Subscription_UpcomingInvoice): GetSubscriptionReply_Subscription_UpcomingInvoice {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string startDate */ 1:
                    message.startDate = reader.string();
                    break;
                case /* string endDate */ 2:
                    message.endDate = reader.string();
                    break;
                case /* string nextPaymentDate */ 3:
                    message.nextPaymentDate = reader.string();
                    break;
                case /* string amountDue */ 4:
                    message.amountDue = reader.string();
                    break;
                case /* string description */ 5:
                    message.description = reader.string();
                    break;
                case /* int64 stripe_quantity */ 6:
                    message.stripeQuantity = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSubscriptionReply_Subscription_UpcomingInvoice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string startDate = 1; */
        if (message.startDate !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.startDate);
        /* string endDate = 2; */
        if (message.endDate !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.endDate);
        /* string nextPaymentDate = 3; */
        if (message.nextPaymentDate !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.nextPaymentDate);
        /* string amountDue = 4; */
        if (message.amountDue !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.amountDue);
        /* string description = 5; */
        if (message.description !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.description);
        /* int64 stripe_quantity = 6; */
        if (message.stripeQuantity !== 0)
            writer.tag(6, WireType.Varint).int64(message.stripeQuantity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetSubscriptionReply.Subscription.UpcomingInvoice
 */
export const GetSubscriptionReply_Subscription_UpcomingInvoice = new GetSubscriptionReply_Subscription_UpcomingInvoice$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSubscriptionReply_Subscription_Tier$Type extends MessageType<GetSubscriptionReply_Subscription_Tier> {
    constructor() {
        super("GetSubscriptionReply.Subscription.Tier", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "price_per_truck_per_month", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "up_to_trucks", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<GetSubscriptionReply_Subscription_Tier>): GetSubscriptionReply_Subscription_Tier {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.pricePerTruckPerMonth = "";
        message.upToTrucks = 0;
        if (value !== undefined)
            reflectionMergePartial<GetSubscriptionReply_Subscription_Tier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSubscriptionReply_Subscription_Tier): GetSubscriptionReply_Subscription_Tier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string price_per_truck_per_month */ 2:
                    message.pricePerTruckPerMonth = reader.string();
                    break;
                case /* int64 up_to_trucks */ 3:
                    message.upToTrucks = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSubscriptionReply_Subscription_Tier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string price_per_truck_per_month = 2; */
        if (message.pricePerTruckPerMonth !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pricePerTruckPerMonth);
        /* int64 up_to_trucks = 3; */
        if (message.upToTrucks !== 0)
            writer.tag(3, WireType.Varint).int64(message.upToTrucks);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetSubscriptionReply.Subscription.Tier
 */
export const GetSubscriptionReply_Subscription_Tier = new GetSubscriptionReply_Subscription_Tier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckoutRequest$Type extends MessageType<CheckoutRequest> {
    constructor() {
        super("CheckoutRequest", []);
    }
    create(value?: PartialMessage<CheckoutRequest>): CheckoutRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CheckoutRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckoutRequest): CheckoutRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CheckoutRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CheckoutRequest
 */
export const CheckoutRequest = new CheckoutRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckoutReply$Type extends MessageType<CheckoutReply> {
    constructor() {
        super("CheckoutReply", [
            { no: 1, name: "session_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CheckoutReply>): CheckoutReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionUrl = "";
        if (value !== undefined)
            reflectionMergePartial<CheckoutReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckoutReply): CheckoutReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string session_url */ 1:
                    message.sessionUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckoutReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string session_url = 1; */
        if (message.sessionUrl !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sessionUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CheckoutReply
 */
export const CheckoutReply = new CheckoutReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetInvoicesRequest$Type extends MessageType<GetInvoicesRequest> {
    constructor() {
        super("GetInvoicesRequest", []);
    }
    create(value?: PartialMessage<GetInvoicesRequest>): GetInvoicesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetInvoicesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetInvoicesRequest): GetInvoicesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetInvoicesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetInvoicesRequest
 */
export const GetInvoicesRequest = new GetInvoicesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetInvoicesReply$Type extends MessageType<GetInvoicesReply> {
    constructor() {
        super("GetInvoicesReply", [
            { no: 1, name: "invoices", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GetInvoicesReply_Invoice }
        ]);
    }
    create(value?: PartialMessage<GetInvoicesReply>): GetInvoicesReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.invoices = [];
        if (value !== undefined)
            reflectionMergePartial<GetInvoicesReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetInvoicesReply): GetInvoicesReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated GetInvoicesReply.Invoice invoices */ 1:
                    message.invoices.push(GetInvoicesReply_Invoice.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetInvoicesReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated GetInvoicesReply.Invoice invoices = 1; */
        for (let i = 0; i < message.invoices.length; i++)
            GetInvoicesReply_Invoice.internalBinaryWrite(message.invoices[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetInvoicesReply
 */
export const GetInvoicesReply = new GetInvoicesReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetInvoicesReply_Invoice$Type extends MessageType<GetInvoicesReply_Invoice> {
    constructor() {
        super("GetInvoicesReply.Invoice", [
            { no: 1, name: "amountDue", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "status", kind: "enum", T: () => ["Settings.Billing.Invoice.Status", Settings_Billing_Invoice_Status] },
            { no: 3, name: "number", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "hosted_invoice_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "invoice_pdf_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "period_start", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "period_end", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetInvoicesReply_Invoice>): GetInvoicesReply_Invoice {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.amountDue = "";
        message.status = 0;
        message.number = "";
        message.hostedInvoiceUrl = "";
        message.invoicePdfUrl = "";
        message.periodStart = "";
        message.periodEnd = "";
        message.description = "";
        if (value !== undefined)
            reflectionMergePartial<GetInvoicesReply_Invoice>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetInvoicesReply_Invoice): GetInvoicesReply_Invoice {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string amountDue */ 1:
                    message.amountDue = reader.string();
                    break;
                case /* Settings.Billing.Invoice.Status status */ 2:
                    message.status = reader.int32();
                    break;
                case /* string number */ 3:
                    message.number = reader.string();
                    break;
                case /* string hosted_invoice_url */ 4:
                    message.hostedInvoiceUrl = reader.string();
                    break;
                case /* string invoice_pdf_url */ 5:
                    message.invoicePdfUrl = reader.string();
                    break;
                case /* string period_start */ 6:
                    message.periodStart = reader.string();
                    break;
                case /* string period_end */ 7:
                    message.periodEnd = reader.string();
                    break;
                case /* string description */ 8:
                    message.description = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetInvoicesReply_Invoice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string amountDue = 1; */
        if (message.amountDue !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.amountDue);
        /* Settings.Billing.Invoice.Status status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).int32(message.status);
        /* string number = 3; */
        if (message.number !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.number);
        /* string hosted_invoice_url = 4; */
        if (message.hostedInvoiceUrl !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.hostedInvoiceUrl);
        /* string invoice_pdf_url = 5; */
        if (message.invoicePdfUrl !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.invoicePdfUrl);
        /* string period_start = 6; */
        if (message.periodStart !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.periodStart);
        /* string period_end = 7; */
        if (message.periodEnd !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.periodEnd);
        /* string description = 8; */
        if (message.description !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.description);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetInvoicesReply.Invoice
 */
export const GetInvoicesReply_Invoice = new GetInvoicesReply_Invoice$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateSessionRequest$Type extends MessageType<CreateSessionRequest> {
    constructor() {
        super("CreateSessionRequest", []);
    }
    create(value?: PartialMessage<CreateSessionRequest>): CreateSessionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateSessionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateSessionRequest): CreateSessionRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CreateSessionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CreateSessionRequest
 */
export const CreateSessionRequest = new CreateSessionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateSessionReply$Type extends MessageType<CreateSessionReply> {
    constructor() {
        super("CreateSessionReply", [
            { no: 1, name: "session_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateSessionReply>): CreateSessionReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionUrl = "";
        if (value !== undefined)
            reflectionMergePartial<CreateSessionReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateSessionReply): CreateSessionReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string session_url */ 1:
                    message.sessionUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateSessionReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string session_url = 1; */
        if (message.sessionUrl !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sessionUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CreateSessionReply
 */
export const CreateSessionReply = new CreateSessionReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CancelAccountRequest$Type extends MessageType<CancelAccountRequest> {
    constructor() {
        super("CancelAccountRequest", []);
    }
    create(value?: PartialMessage<CancelAccountRequest>): CancelAccountRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CancelAccountRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CancelAccountRequest): CancelAccountRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CancelAccountRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CancelAccountRequest
 */
export const CancelAccountRequest = new CancelAccountRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CancelAccountReply$Type extends MessageType<CancelAccountReply> {
    constructor() {
        super("CancelAccountReply", []);
    }
    create(value?: PartialMessage<CancelAccountReply>): CancelAccountReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CancelAccountReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CancelAccountReply): CancelAccountReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CancelAccountReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CancelAccountReply
 */
export const CancelAccountReply = new CancelAccountReply$Type();
/**
 * @generated ServiceType for protobuf service SettingsBillingService
 */
export const SettingsBillingService = new ServiceType("SettingsBillingService", [
    { name: "GetPaymentMethod", options: {}, I: GetPaymentMethodRequest, O: GetPaymentMethodReply },
    { name: "GetSubscription", options: {}, I: GetSubscriptionRequest, O: GetSubscriptionReply },
    { name: "Checkout", options: {}, I: CheckoutRequest, O: CheckoutReply },
    { name: "GetInvoices", options: {}, I: GetInvoicesRequest, O: GetInvoicesReply },
    { name: "CreateSession", options: {}, I: CreateSessionRequest, O: CreateSessionReply },
    { name: "CancelAccount", options: {}, I: CancelAccountRequest, O: CancelAccountReply }
]);
