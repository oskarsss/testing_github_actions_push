// @generated by protobuf-ts 2.9.4 with parameter long_type_number,generate_dependencies,ts_nocheck,output_typescript
// @generated from protobuf file "v1/models/model_document.proto" (syntax proto3)
// tslint:disable
// @ts-nocheck
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message DocumentModel
 */
export interface DocumentModel {
}
/**
 * @generated from protobuf message DocumentModel.Document
 */
export interface DocumentModel_Document {
    /**
     * @generated from protobuf field: string document_type_id = 2;
     */
    documentTypeId: string;
    /**
     * @generated from protobuf field: string file_id = 3;
     */
    fileId: string;
    /**
     * @generated from protobuf field: string thumb_file_id = 4;
     */
    thumbFileId: string;
    /**
     * @generated from protobuf field: string number = 5;
     */
    number: string;
    /**
     * @generated from protobuf field: string state = 6;
     */
    state: string;
    /**
     * @generated from protobuf field: bool expired = 7;
     */
    expired: boolean;
    /**
     * @generated from protobuf field: string expires_at = 8;
     */
    expiresAt: string;
    /**
     * @generated from protobuf field: DocumentModel.Status status = 9;
     */
    status: DocumentModel_Status;
    /**
     * @generated from protobuf field: string updated_at = 10;
     */
    updatedAt: string;
    /**
     * @generated from protobuf field: string created_at = 11;
     */
    createdAt: string;
}
/**
 * @generated from protobuf message DocumentModel.Version
 */
export interface DocumentModel_Version {
    /**
     * @generated from protobuf field: int64 version = 1;
     */
    version: number;
    /**
     * @generated from protobuf field: string file_id = 2;
     */
    fileId: string;
    /**
     * @generated from protobuf field: string thumb_file_id = 3;
     */
    thumbFileId: string;
    /**
     * @generated from protobuf field: string uploaded_by_user_id = 4;
     */
    uploadedByUserId: string;
    /**
     * @generated from protobuf field: string uploaded_by_driver_id = 5;
     */
    uploadedByDriverId: string;
    /**
     * @generated from protobuf field: string created_at = 6;
     */
    createdAt: string;
}
/**
 * @generated from protobuf message DocumentModel.Type
 */
export interface DocumentModel_Type {
    /**
     * @generated from protobuf field: string document_type_id = 1;
     */
    documentTypeId: string;
    /**
     * @generated from protobuf field: string title = 2;
     */
    title: string;
    /**
     * @generated from protobuf field: DocumentModel.DocumentEntityType entity_type = 3;
     */
    entityType: DocumentModel_DocumentEntityType;
    /**
     * @generated from protobuf field: DocumentModel.Type.State state = 4;
     */
    state?: DocumentModel_Type_State;
    /**
     * @generated from protobuf field: DocumentModel.Type.Country country = 5;
     */
    country?: DocumentModel_Type_Country;
    /**
     * @generated from protobuf field: bool expirable = 6;
     */
    expirable: boolean;
    /**
     * @generated from protobuf field: bool number_supported = 7;
     */
    numberSupported: boolean;
    /**
     * @generated from protobuf field: bool status_supported = 8;
     */
    statusSupported: boolean;
    /**
     * @generated from protobuf field: bool required = 9;
     */
    required: boolean;
    /**
     * @generated from protobuf field: bool can_driver_update = 10;
     */
    canDriverUpdate: boolean;
    /**
     * @generated from protobuf field: bool can_driver_view = 11;
     */
    canDriverView: boolean;
    /**
     * @generated from protobuf field: int64 sequence = 12;
     */
    sequence: number;
    /**
     * @generated from protobuf field: bool deleted = 13;
     */
    deleted: boolean;
}
/**
 * @generated from protobuf message DocumentModel.Type.State
 */
export interface DocumentModel_Type_State {
    /**
     * @generated from protobuf field: bool supported = 1;
     */
    supported: boolean;
    /**
     * @generated from protobuf field: string default = 2;
     */
    default: string;
}
/**
 * @generated from protobuf message DocumentModel.Type.Country
 */
export interface DocumentModel_Type_Country {
    /**
     * @generated from protobuf field: bool supported = 1;
     */
    supported: boolean;
    /**
     * @generated from protobuf field: string default = 2;
     */
    default: string;
}
/**
 * @generated from protobuf enum DocumentModel.Status
 */
export enum DocumentModel_Status {
    /**
     * @generated from protobuf enum value: DOCUMENT_STATUS_UNSPECIFIED = 0;
     */
    DOCUMENT_STATUS_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: DOCUMENT_STATUS_PENDING = 1;
     */
    DOCUMENT_STATUS_PENDING = 1,
    /**
     * @generated from protobuf enum value: DOCUMENT_STATUS_VALID = 2;
     */
    DOCUMENT_STATUS_VALID = 2,
    /**
     * @generated from protobuf enum value: DOCUMENT_STATUS_INVALID = 3;
     */
    DOCUMENT_STATUS_INVALID = 3,
    /**
     * @generated from protobuf enum value: DOCUMENT_STATUS_DELETED = 4;
     */
    DOCUMENT_STATUS_DELETED = 4
}
/**
 * @generated from protobuf enum DocumentModel.DocumentEntityType
 */
export enum DocumentModel_DocumentEntityType {
    /**
     * @generated from protobuf enum value: DOCUMENT_ENTITY_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: DOCUMENT_ENTITY_TYPE_LOAD = 1;
     */
    LOAD = 1,
    /**
     * @generated from protobuf enum value: DOCUMENT_ENTITY_TYPE_TRUCK = 2;
     */
    TRUCK = 2,
    /**
     * @generated from protobuf enum value: DOCUMENT_ENTITY_TYPE_TRAILER = 3;
     */
    TRAILER = 3,
    /**
     * @generated from protobuf enum value: DOCUMENT_ENTITY_TYPE_TRAILER_COMPANY = 4;
     */
    TRAILER_COMPANY = 4,
    /**
     * @generated from protobuf enum value: DOCUMENT_ENTITY_TYPE_DRIVER = 5;
     */
    DRIVER = 5,
    /**
     * @generated from protobuf enum value: DOCUMENT_ENTITY_TYPE_PLATE = 6;
     */
    PLATE = 6,
    /**
     * @generated from protobuf enum value: DOCUMENT_ENTITY_TYPE_VENDOR = 7;
     */
    VENDOR = 7,
    /**
     * @generated from protobuf enum value: DOCUMENT_ENTITY_TYPE_CUSTOMER = 8;
     */
    CUSTOMER = 8,
    /**
     * @generated from protobuf enum value: DOCUMENT_ENTITY_TYPE_BROKER = 9;
     */
    BROKER = 9,
    /**
     * @generated from protobuf enum value: DOCUMENT_ENTITY_TYPE_COMPANY = 10;
     */
    COMPANY = 10,
    /**
     * @generated from protobuf enum value: DOCUMENT_ENTITY_TYPE_PLATE_COMPANY = 11;
     */
    PLATE_COMPANY = 11,
    /**
     * @generated from protobuf enum value: DOCUMENT_ENTITY_TYPE_LOAN = 12;
     */
    LOAN = 12,
    /**
     * @generated from protobuf enum value: DOCUMENT_ENTITY_TYPE_VEHICLE_WARRANTY = 13;
     */
    VEHICLE_WARRANTY = 13,
    /**
     * @generated from protobuf enum value: DOCUMENT_ENTITY_TYPE_SERVICE_LOG = 14;
     */
    SERVICE_LOG = 14
}
// @generated message type with reflection information, may provide speed optimized methods
class DocumentModel$Type extends MessageType<DocumentModel> {
    constructor() {
        super("DocumentModel", []);
    }
    create(value?: PartialMessage<DocumentModel>): DocumentModel {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DocumentModel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentModel): DocumentModel {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DocumentModel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentModel
 */
export const DocumentModel = new DocumentModel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentModel_Document$Type extends MessageType<DocumentModel_Document> {
    constructor() {
        super("DocumentModel.Document", [
            { no: 2, name: "document_type_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "file_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "thumb_file_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "number", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "expired", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "expires_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "status", kind: "enum", T: () => ["DocumentModel.Status", DocumentModel_Status] },
            { no: 10, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentModel_Document>): DocumentModel_Document {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.documentTypeId = "";
        message.fileId = "";
        message.thumbFileId = "";
        message.number = "";
        message.state = "";
        message.expired = false;
        message.expiresAt = "";
        message.status = 0;
        message.updatedAt = "";
        message.createdAt = "";
        if (value !== undefined)
            reflectionMergePartial<DocumentModel_Document>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentModel_Document): DocumentModel_Document {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string document_type_id */ 2:
                    message.documentTypeId = reader.string();
                    break;
                case /* string file_id */ 3:
                    message.fileId = reader.string();
                    break;
                case /* string thumb_file_id */ 4:
                    message.thumbFileId = reader.string();
                    break;
                case /* string number */ 5:
                    message.number = reader.string();
                    break;
                case /* string state */ 6:
                    message.state = reader.string();
                    break;
                case /* bool expired */ 7:
                    message.expired = reader.bool();
                    break;
                case /* string expires_at */ 8:
                    message.expiresAt = reader.string();
                    break;
                case /* DocumentModel.Status status */ 9:
                    message.status = reader.int32();
                    break;
                case /* string updated_at */ 10:
                    message.updatedAt = reader.string();
                    break;
                case /* string created_at */ 11:
                    message.createdAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentModel_Document, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string document_type_id = 2; */
        if (message.documentTypeId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.documentTypeId);
        /* string file_id = 3; */
        if (message.fileId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.fileId);
        /* string thumb_file_id = 4; */
        if (message.thumbFileId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.thumbFileId);
        /* string number = 5; */
        if (message.number !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.number);
        /* string state = 6; */
        if (message.state !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.state);
        /* bool expired = 7; */
        if (message.expired !== false)
            writer.tag(7, WireType.Varint).bool(message.expired);
        /* string expires_at = 8; */
        if (message.expiresAt !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.expiresAt);
        /* DocumentModel.Status status = 9; */
        if (message.status !== 0)
            writer.tag(9, WireType.Varint).int32(message.status);
        /* string updated_at = 10; */
        if (message.updatedAt !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.updatedAt);
        /* string created_at = 11; */
        if (message.createdAt !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.createdAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentModel.Document
 */
export const DocumentModel_Document = new DocumentModel_Document$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentModel_Version$Type extends MessageType<DocumentModel_Version> {
    constructor() {
        super("DocumentModel.Version", [
            { no: 1, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "file_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "thumb_file_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "uploaded_by_user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "uploaded_by_driver_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentModel_Version>): DocumentModel_Version {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = 0;
        message.fileId = "";
        message.thumbFileId = "";
        message.uploadedByUserId = "";
        message.uploadedByDriverId = "";
        message.createdAt = "";
        if (value !== undefined)
            reflectionMergePartial<DocumentModel_Version>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentModel_Version): DocumentModel_Version {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 version */ 1:
                    message.version = reader.int64().toNumber();
                    break;
                case /* string file_id */ 2:
                    message.fileId = reader.string();
                    break;
                case /* string thumb_file_id */ 3:
                    message.thumbFileId = reader.string();
                    break;
                case /* string uploaded_by_user_id */ 4:
                    message.uploadedByUserId = reader.string();
                    break;
                case /* string uploaded_by_driver_id */ 5:
                    message.uploadedByDriverId = reader.string();
                    break;
                case /* string created_at */ 6:
                    message.createdAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentModel_Version, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 version = 1; */
        if (message.version !== 0)
            writer.tag(1, WireType.Varint).int64(message.version);
        /* string file_id = 2; */
        if (message.fileId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.fileId);
        /* string thumb_file_id = 3; */
        if (message.thumbFileId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.thumbFileId);
        /* string uploaded_by_user_id = 4; */
        if (message.uploadedByUserId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.uploadedByUserId);
        /* string uploaded_by_driver_id = 5; */
        if (message.uploadedByDriverId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.uploadedByDriverId);
        /* string created_at = 6; */
        if (message.createdAt !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.createdAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentModel.Version
 */
export const DocumentModel_Version = new DocumentModel_Version$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentModel_Type$Type extends MessageType<DocumentModel_Type> {
    constructor() {
        super("DocumentModel.Type", [
            { no: 1, name: "document_type_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "entity_type", kind: "enum", T: () => ["DocumentModel.DocumentEntityType", DocumentModel_DocumentEntityType, "DOCUMENT_ENTITY_TYPE_"] },
            { no: 4, name: "state", kind: "message", T: () => DocumentModel_Type_State },
            { no: 5, name: "country", kind: "message", T: () => DocumentModel_Type_Country },
            { no: 6, name: "expirable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "number_supported", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "status_supported", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "required", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "can_driver_update", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "can_driver_view", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "sequence", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 13, name: "deleted", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentModel_Type>): DocumentModel_Type {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.documentTypeId = "";
        message.title = "";
        message.entityType = 0;
        message.expirable = false;
        message.numberSupported = false;
        message.statusSupported = false;
        message.required = false;
        message.canDriverUpdate = false;
        message.canDriverView = false;
        message.sequence = 0;
        message.deleted = false;
        if (value !== undefined)
            reflectionMergePartial<DocumentModel_Type>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentModel_Type): DocumentModel_Type {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string document_type_id */ 1:
                    message.documentTypeId = reader.string();
                    break;
                case /* string title */ 2:
                    message.title = reader.string();
                    break;
                case /* DocumentModel.DocumentEntityType entity_type */ 3:
                    message.entityType = reader.int32();
                    break;
                case /* DocumentModel.Type.State state */ 4:
                    message.state = DocumentModel_Type_State.internalBinaryRead(reader, reader.uint32(), options, message.state);
                    break;
                case /* DocumentModel.Type.Country country */ 5:
                    message.country = DocumentModel_Type_Country.internalBinaryRead(reader, reader.uint32(), options, message.country);
                    break;
                case /* bool expirable */ 6:
                    message.expirable = reader.bool();
                    break;
                case /* bool number_supported */ 7:
                    message.numberSupported = reader.bool();
                    break;
                case /* bool status_supported */ 8:
                    message.statusSupported = reader.bool();
                    break;
                case /* bool required */ 9:
                    message.required = reader.bool();
                    break;
                case /* bool can_driver_update */ 10:
                    message.canDriverUpdate = reader.bool();
                    break;
                case /* bool can_driver_view */ 11:
                    message.canDriverView = reader.bool();
                    break;
                case /* int64 sequence */ 12:
                    message.sequence = reader.int64().toNumber();
                    break;
                case /* bool deleted */ 13:
                    message.deleted = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentModel_Type, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string document_type_id = 1; */
        if (message.documentTypeId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.documentTypeId);
        /* string title = 2; */
        if (message.title !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.title);
        /* DocumentModel.DocumentEntityType entity_type = 3; */
        if (message.entityType !== 0)
            writer.tag(3, WireType.Varint).int32(message.entityType);
        /* DocumentModel.Type.State state = 4; */
        if (message.state)
            DocumentModel_Type_State.internalBinaryWrite(message.state, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* DocumentModel.Type.Country country = 5; */
        if (message.country)
            DocumentModel_Type_Country.internalBinaryWrite(message.country, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bool expirable = 6; */
        if (message.expirable !== false)
            writer.tag(6, WireType.Varint).bool(message.expirable);
        /* bool number_supported = 7; */
        if (message.numberSupported !== false)
            writer.tag(7, WireType.Varint).bool(message.numberSupported);
        /* bool status_supported = 8; */
        if (message.statusSupported !== false)
            writer.tag(8, WireType.Varint).bool(message.statusSupported);
        /* bool required = 9; */
        if (message.required !== false)
            writer.tag(9, WireType.Varint).bool(message.required);
        /* bool can_driver_update = 10; */
        if (message.canDriverUpdate !== false)
            writer.tag(10, WireType.Varint).bool(message.canDriverUpdate);
        /* bool can_driver_view = 11; */
        if (message.canDriverView !== false)
            writer.tag(11, WireType.Varint).bool(message.canDriverView);
        /* int64 sequence = 12; */
        if (message.sequence !== 0)
            writer.tag(12, WireType.Varint).int64(message.sequence);
        /* bool deleted = 13; */
        if (message.deleted !== false)
            writer.tag(13, WireType.Varint).bool(message.deleted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentModel.Type
 */
export const DocumentModel_Type = new DocumentModel_Type$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentModel_Type_State$Type extends MessageType<DocumentModel_Type_State> {
    constructor() {
        super("DocumentModel.Type.State", [
            { no: 1, name: "supported", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "default", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentModel_Type_State>): DocumentModel_Type_State {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.supported = false;
        message.default = "";
        if (value !== undefined)
            reflectionMergePartial<DocumentModel_Type_State>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentModel_Type_State): DocumentModel_Type_State {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool supported */ 1:
                    message.supported = reader.bool();
                    break;
                case /* string default */ 2:
                    message.default = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentModel_Type_State, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool supported = 1; */
        if (message.supported !== false)
            writer.tag(1, WireType.Varint).bool(message.supported);
        /* string default = 2; */
        if (message.default !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.default);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentModel.Type.State
 */
export const DocumentModel_Type_State = new DocumentModel_Type_State$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentModel_Type_Country$Type extends MessageType<DocumentModel_Type_Country> {
    constructor() {
        super("DocumentModel.Type.Country", [
            { no: 1, name: "supported", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "default", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentModel_Type_Country>): DocumentModel_Type_Country {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.supported = false;
        message.default = "";
        if (value !== undefined)
            reflectionMergePartial<DocumentModel_Type_Country>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentModel_Type_Country): DocumentModel_Type_Country {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool supported */ 1:
                    message.supported = reader.bool();
                    break;
                case /* string default */ 2:
                    message.default = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentModel_Type_Country, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool supported = 1; */
        if (message.supported !== false)
            writer.tag(1, WireType.Varint).bool(message.supported);
        /* string default = 2; */
        if (message.default !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.default);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentModel.Type.Country
 */
export const DocumentModel_Type_Country = new DocumentModel_Type_Country$Type();
