// @generated by protobuf-ts 2.9.4 with parameter long_type_number,generate_dependencies,ts_nocheck,output_typescript
// @generated from protobuf file "v1/service_log_item.proto" (syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { ServiceLogItemModel_ItemRead } from "./models/model_service_log_item";
import { ServiceLogItemModel_Error } from "./models/model_service_log_item";
import { ServiceLogItemModel_ItemWrite } from "./models/model_service_log_item";
/**
 * Create
 *
 * @generated from protobuf message ServiceLogItemCreateRequest
 */
export interface ServiceLogItemCreateRequest {
    /**
     * @generated from protobuf field: string service_log_id = 1;
     */
    serviceLogId: string;
    /**
     * @generated from protobuf field: repeated ServiceLogItemModel.ItemWrite base_items = 2;
     */
    baseItems: ServiceLogItemModel_ItemWrite[];
}
/**
 * @generated from protobuf message ServiceLogItemCreateReply
 */
export interface ServiceLogItemCreateReply {
    /**
     * If error in items always return replay w/o endpoint call error but with error array in the replay. In this case ids will be empty.
     * if error not in items, but e.g. in total sum calculation, items error array and ids are empty, but endpoint call error is returned
     * If endpoint call succeeds, ids are filled and error array is empty
     *
     * @generated from protobuf field: repeated string service_log_item_ids = 1;
     */
    serviceLogItemIds: string[];
    /**
     * @generated from protobuf field: repeated ServiceLogItemModel.Error errors = 2;
     */
    errors: ServiceLogItemModel_Error[];
}
/**
 * Update
 *
 * @generated from protobuf message ServiceLogItemUpdateRequest
 */
export interface ServiceLogItemUpdateRequest {
    /**
     * @generated from protobuf field: string service_log_id = 1;
     */
    serviceLogId: string;
    /**
     * @generated from protobuf field: string service_log_item_id = 2;
     */
    serviceLogItemId: string;
    /**
     * @generated from protobuf field: ServiceLogItemModel.ItemWrite base_item = 3;
     */
    baseItem?: ServiceLogItemModel_ItemWrite;
}
/**
 * @generated from protobuf message ServiceLogItemUpdateReply
 */
export interface ServiceLogItemUpdateReply {
}
/**
 * Retrieve
 *
 * @generated from protobuf message ServiceLogItemRetrieveRequest
 */
export interface ServiceLogItemRetrieveRequest {
    /**
     * @generated from protobuf field: string service_log_id = 1;
     */
    serviceLogId: string;
    /**
     * @generated from protobuf field: string service_log_item_id = 2;
     */
    serviceLogItemId: string;
}
/**
 * @generated from protobuf message ServiceLogItemRetrieveReply
 */
export interface ServiceLogItemRetrieveReply {
    /**
     * @generated from protobuf field: ServiceLogItemModel.ItemRead base_item = 1;
     */
    baseItem?: ServiceLogItemModel_ItemRead;
}
/**
 * Get
 *
 * @generated from protobuf message ServiceLogItemGetRequest
 */
export interface ServiceLogItemGetRequest {
    /**
     * @generated from protobuf field: string service_log_id = 1;
     */
    serviceLogId: string;
}
/**
 * @generated from protobuf message ServiceLogItemGetReply
 */
export interface ServiceLogItemGetReply {
    /**
     * @generated from protobuf field: repeated ServiceLogItemModel.ItemRead base_item = 1;
     */
    baseItem: ServiceLogItemModel_ItemRead[];
}
/**
 * Delete
 *
 * @generated from protobuf message ServiceLogItemDeleteRequest
 */
export interface ServiceLogItemDeleteRequest {
    /**
     * @generated from protobuf field: string service_log_id = 1;
     */
    serviceLogId: string;
    /**
     * @generated from protobuf field: string service_log_item_id = 2;
     */
    serviceLogItemId: string;
}
/**
 * @generated from protobuf message ServiceLogItemDeleteReply
 */
export interface ServiceLogItemDeleteReply {
}
// @generated message type with reflection information, may provide speed optimized methods
class ServiceLogItemCreateRequest$Type extends MessageType<ServiceLogItemCreateRequest> {
    constructor() {
        super("ServiceLogItemCreateRequest", [
            { no: 1, name: "service_log_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "base_items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ServiceLogItemModel_ItemWrite }
        ]);
    }
    create(value?: PartialMessage<ServiceLogItemCreateRequest>): ServiceLogItemCreateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serviceLogId = "";
        message.baseItems = [];
        if (value !== undefined)
            reflectionMergePartial<ServiceLogItemCreateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServiceLogItemCreateRequest): ServiceLogItemCreateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string service_log_id */ 1:
                    message.serviceLogId = reader.string();
                    break;
                case /* repeated ServiceLogItemModel.ItemWrite base_items */ 2:
                    message.baseItems.push(ServiceLogItemModel_ItemWrite.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServiceLogItemCreateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string service_log_id = 1; */
        if (message.serviceLogId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.serviceLogId);
        /* repeated ServiceLogItemModel.ItemWrite base_items = 2; */
        for (let i = 0; i < message.baseItems.length; i++)
            ServiceLogItemModel_ItemWrite.internalBinaryWrite(message.baseItems[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ServiceLogItemCreateRequest
 */
export const ServiceLogItemCreateRequest = new ServiceLogItemCreateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServiceLogItemCreateReply$Type extends MessageType<ServiceLogItemCreateReply> {
    constructor() {
        super("ServiceLogItemCreateReply", [
            { no: 1, name: "service_log_item_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "errors", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ServiceLogItemModel_Error }
        ]);
    }
    create(value?: PartialMessage<ServiceLogItemCreateReply>): ServiceLogItemCreateReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serviceLogItemIds = [];
        message.errors = [];
        if (value !== undefined)
            reflectionMergePartial<ServiceLogItemCreateReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServiceLogItemCreateReply): ServiceLogItemCreateReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string service_log_item_ids */ 1:
                    message.serviceLogItemIds.push(reader.string());
                    break;
                case /* repeated ServiceLogItemModel.Error errors */ 2:
                    message.errors.push(ServiceLogItemModel_Error.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServiceLogItemCreateReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string service_log_item_ids = 1; */
        for (let i = 0; i < message.serviceLogItemIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.serviceLogItemIds[i]);
        /* repeated ServiceLogItemModel.Error errors = 2; */
        for (let i = 0; i < message.errors.length; i++)
            ServiceLogItemModel_Error.internalBinaryWrite(message.errors[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ServiceLogItemCreateReply
 */
export const ServiceLogItemCreateReply = new ServiceLogItemCreateReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServiceLogItemUpdateRequest$Type extends MessageType<ServiceLogItemUpdateRequest> {
    constructor() {
        super("ServiceLogItemUpdateRequest", [
            { no: 1, name: "service_log_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "service_log_item_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "base_item", kind: "message", T: () => ServiceLogItemModel_ItemWrite }
        ]);
    }
    create(value?: PartialMessage<ServiceLogItemUpdateRequest>): ServiceLogItemUpdateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serviceLogId = "";
        message.serviceLogItemId = "";
        if (value !== undefined)
            reflectionMergePartial<ServiceLogItemUpdateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServiceLogItemUpdateRequest): ServiceLogItemUpdateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string service_log_id */ 1:
                    message.serviceLogId = reader.string();
                    break;
                case /* string service_log_item_id */ 2:
                    message.serviceLogItemId = reader.string();
                    break;
                case /* ServiceLogItemModel.ItemWrite base_item */ 3:
                    message.baseItem = ServiceLogItemModel_ItemWrite.internalBinaryRead(reader, reader.uint32(), options, message.baseItem);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServiceLogItemUpdateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string service_log_id = 1; */
        if (message.serviceLogId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.serviceLogId);
        /* string service_log_item_id = 2; */
        if (message.serviceLogItemId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.serviceLogItemId);
        /* ServiceLogItemModel.ItemWrite base_item = 3; */
        if (message.baseItem)
            ServiceLogItemModel_ItemWrite.internalBinaryWrite(message.baseItem, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ServiceLogItemUpdateRequest
 */
export const ServiceLogItemUpdateRequest = new ServiceLogItemUpdateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServiceLogItemUpdateReply$Type extends MessageType<ServiceLogItemUpdateReply> {
    constructor() {
        super("ServiceLogItemUpdateReply", []);
    }
    create(value?: PartialMessage<ServiceLogItemUpdateReply>): ServiceLogItemUpdateReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ServiceLogItemUpdateReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServiceLogItemUpdateReply): ServiceLogItemUpdateReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ServiceLogItemUpdateReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ServiceLogItemUpdateReply
 */
export const ServiceLogItemUpdateReply = new ServiceLogItemUpdateReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServiceLogItemRetrieveRequest$Type extends MessageType<ServiceLogItemRetrieveRequest> {
    constructor() {
        super("ServiceLogItemRetrieveRequest", [
            { no: 1, name: "service_log_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "service_log_item_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ServiceLogItemRetrieveRequest>): ServiceLogItemRetrieveRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serviceLogId = "";
        message.serviceLogItemId = "";
        if (value !== undefined)
            reflectionMergePartial<ServiceLogItemRetrieveRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServiceLogItemRetrieveRequest): ServiceLogItemRetrieveRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string service_log_id */ 1:
                    message.serviceLogId = reader.string();
                    break;
                case /* string service_log_item_id */ 2:
                    message.serviceLogItemId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServiceLogItemRetrieveRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string service_log_id = 1; */
        if (message.serviceLogId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.serviceLogId);
        /* string service_log_item_id = 2; */
        if (message.serviceLogItemId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.serviceLogItemId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ServiceLogItemRetrieveRequest
 */
export const ServiceLogItemRetrieveRequest = new ServiceLogItemRetrieveRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServiceLogItemRetrieveReply$Type extends MessageType<ServiceLogItemRetrieveReply> {
    constructor() {
        super("ServiceLogItemRetrieveReply", [
            { no: 1, name: "base_item", kind: "message", T: () => ServiceLogItemModel_ItemRead }
        ]);
    }
    create(value?: PartialMessage<ServiceLogItemRetrieveReply>): ServiceLogItemRetrieveReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ServiceLogItemRetrieveReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServiceLogItemRetrieveReply): ServiceLogItemRetrieveReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ServiceLogItemModel.ItemRead base_item */ 1:
                    message.baseItem = ServiceLogItemModel_ItemRead.internalBinaryRead(reader, reader.uint32(), options, message.baseItem);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServiceLogItemRetrieveReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ServiceLogItemModel.ItemRead base_item = 1; */
        if (message.baseItem)
            ServiceLogItemModel_ItemRead.internalBinaryWrite(message.baseItem, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ServiceLogItemRetrieveReply
 */
export const ServiceLogItemRetrieveReply = new ServiceLogItemRetrieveReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServiceLogItemGetRequest$Type extends MessageType<ServiceLogItemGetRequest> {
    constructor() {
        super("ServiceLogItemGetRequest", [
            { no: 1, name: "service_log_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ServiceLogItemGetRequest>): ServiceLogItemGetRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serviceLogId = "";
        if (value !== undefined)
            reflectionMergePartial<ServiceLogItemGetRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServiceLogItemGetRequest): ServiceLogItemGetRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string service_log_id */ 1:
                    message.serviceLogId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServiceLogItemGetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string service_log_id = 1; */
        if (message.serviceLogId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.serviceLogId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ServiceLogItemGetRequest
 */
export const ServiceLogItemGetRequest = new ServiceLogItemGetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServiceLogItemGetReply$Type extends MessageType<ServiceLogItemGetReply> {
    constructor() {
        super("ServiceLogItemGetReply", [
            { no: 1, name: "base_item", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ServiceLogItemModel_ItemRead }
        ]);
    }
    create(value?: PartialMessage<ServiceLogItemGetReply>): ServiceLogItemGetReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.baseItem = [];
        if (value !== undefined)
            reflectionMergePartial<ServiceLogItemGetReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServiceLogItemGetReply): ServiceLogItemGetReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated ServiceLogItemModel.ItemRead base_item */ 1:
                    message.baseItem.push(ServiceLogItemModel_ItemRead.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServiceLogItemGetReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated ServiceLogItemModel.ItemRead base_item = 1; */
        for (let i = 0; i < message.baseItem.length; i++)
            ServiceLogItemModel_ItemRead.internalBinaryWrite(message.baseItem[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ServiceLogItemGetReply
 */
export const ServiceLogItemGetReply = new ServiceLogItemGetReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServiceLogItemDeleteRequest$Type extends MessageType<ServiceLogItemDeleteRequest> {
    constructor() {
        super("ServiceLogItemDeleteRequest", [
            { no: 1, name: "service_log_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "service_log_item_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ServiceLogItemDeleteRequest>): ServiceLogItemDeleteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serviceLogId = "";
        message.serviceLogItemId = "";
        if (value !== undefined)
            reflectionMergePartial<ServiceLogItemDeleteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServiceLogItemDeleteRequest): ServiceLogItemDeleteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string service_log_id */ 1:
                    message.serviceLogId = reader.string();
                    break;
                case /* string service_log_item_id */ 2:
                    message.serviceLogItemId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServiceLogItemDeleteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string service_log_id = 1; */
        if (message.serviceLogId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.serviceLogId);
        /* string service_log_item_id = 2; */
        if (message.serviceLogItemId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.serviceLogItemId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ServiceLogItemDeleteRequest
 */
export const ServiceLogItemDeleteRequest = new ServiceLogItemDeleteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServiceLogItemDeleteReply$Type extends MessageType<ServiceLogItemDeleteReply> {
    constructor() {
        super("ServiceLogItemDeleteReply", []);
    }
    create(value?: PartialMessage<ServiceLogItemDeleteReply>): ServiceLogItemDeleteReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ServiceLogItemDeleteReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServiceLogItemDeleteReply): ServiceLogItemDeleteReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ServiceLogItemDeleteReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ServiceLogItemDeleteReply
 */
export const ServiceLogItemDeleteReply = new ServiceLogItemDeleteReply$Type();
/**
 * @generated ServiceType for protobuf service ServiceLogItemService
 */
export const ServiceLogItemService = new ServiceType("ServiceLogItemService", [
    { name: "ServiceLogItemCreate", options: {}, I: ServiceLogItemCreateRequest, O: ServiceLogItemCreateReply },
    { name: "ServiceLogItemRetrieve", options: {}, I: ServiceLogItemRetrieveRequest, O: ServiceLogItemRetrieveReply },
    { name: "ServiceLogItemGet", options: {}, I: ServiceLogItemGetRequest, O: ServiceLogItemGetReply },
    { name: "ServiceLogItemUpdate", options: {}, I: ServiceLogItemUpdateRequest, O: ServiceLogItemUpdateReply },
    { name: "ServiceLogItemDelete", options: {}, I: ServiceLogItemDeleteRequest, O: ServiceLogItemDeleteReply }
]);
