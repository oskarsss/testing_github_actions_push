// @generated by protobuf-ts 2.9.4 with parameter long_type_number,generate_dependencies,ts_nocheck,output_typescript
// @generated from protobuf file "v1/domain.proto" (syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * /////////////////////////
 * DomainGet
 * /////////////////////////
 *
 * @generated from protobuf message DomainGetRequest
 */
export interface DomainGetRequest {
}
/**
 * @generated from protobuf message DomainGetReply
 */
export interface DomainGetReply {
    /**
     * @generated from protobuf field: repeated DomainGetReply.Domain domains = 1;
     */
    domains: DomainGetReply_Domain[];
}
/**
 * @generated from protobuf message DomainGetReply.Domain
 */
export interface DomainGetReply_Domain {
    /**
     * @generated from protobuf field: string domain_id = 1;
     */
    domainId: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: bool verified = 3;
     */
    verified: boolean;
    /**
     * @generated from protobuf field: DomainGetReply.Domain.DNS dns = 4;
     */
    dns?: DomainGetReply_Domain_DNS;
}
/**
 * @generated from protobuf message DomainGetReply.Domain.DNS
 */
export interface DomainGetReply_Domain_DNS {
    /**
     * @generated from protobuf field: bool misconfigured = 1;
     */
    misconfigured: boolean;
    /**
     * @generated from protobuf field: bool verified = 2;
     */
    verified: boolean;
    /**
     * @generated from protobuf field: repeated DomainGetReply.Domain.DNS.MissingRecord missing_records = 3;
     */
    missingRecords: DomainGetReply_Domain_DNS_MissingRecord[];
    /**
     * @generated from protobuf field: repeated DomainGetReply.Domain.DNS.RequiredVerification required_verifications = 4;
     */
    requiredVerifications: DomainGetReply_Domain_DNS_RequiredVerification[];
}
/**
 * @generated from protobuf message DomainGetReply.Domain.DNS.MissingRecord
 */
export interface DomainGetReply_Domain_DNS_MissingRecord {
    /**
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: string value = 3;
     */
    value: string;
}
/**
 * @generated from protobuf message DomainGetReply.Domain.DNS.RequiredVerification
 */
export interface DomainGetReply_Domain_DNS_RequiredVerification {
    /**
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * @generated from protobuf field: string domain = 2;
     */
    domain: string;
    /**
     * @generated from protobuf field: string value = 3;
     */
    value: string;
}
/**
 * /////////////////////////
 * DomainCreate
 * /////////////////////////
 *
 * @generated from protobuf message DomainCreateRequest
 */
export interface DomainCreateRequest {
    /**
     * @generated from protobuf field: string domain_name = 1;
     */
    domainName: string;
}
/**
 * @generated from protobuf message DomainCreateReply
 */
export interface DomainCreateReply {
}
/**
 * /////////////////////////
 * DomainDelete
 * /////////////////////////
 *
 * @generated from protobuf message DomainDeleteRequest
 */
export interface DomainDeleteRequest {
    /**
     * @generated from protobuf field: string domain_id = 1;
     */
    domainId: string;
}
/**
 * @generated from protobuf message DomainDeleteReply
 */
export interface DomainDeleteReply {
}
// @generated message type with reflection information, may provide speed optimized methods
class DomainGetRequest$Type extends MessageType<DomainGetRequest> {
    constructor() {
        super("DomainGetRequest", []);
    }
    create(value?: PartialMessage<DomainGetRequest>): DomainGetRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DomainGetRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DomainGetRequest): DomainGetRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DomainGetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DomainGetRequest
 */
export const DomainGetRequest = new DomainGetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DomainGetReply$Type extends MessageType<DomainGetReply> {
    constructor() {
        super("DomainGetReply", [
            { no: 1, name: "domains", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DomainGetReply_Domain }
        ]);
    }
    create(value?: PartialMessage<DomainGetReply>): DomainGetReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.domains = [];
        if (value !== undefined)
            reflectionMergePartial<DomainGetReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DomainGetReply): DomainGetReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated DomainGetReply.Domain domains */ 1:
                    message.domains.push(DomainGetReply_Domain.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DomainGetReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated DomainGetReply.Domain domains = 1; */
        for (let i = 0; i < message.domains.length; i++)
            DomainGetReply_Domain.internalBinaryWrite(message.domains[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DomainGetReply
 */
export const DomainGetReply = new DomainGetReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DomainGetReply_Domain$Type extends MessageType<DomainGetReply_Domain> {
    constructor() {
        super("DomainGetReply.Domain", [
            { no: 1, name: "domain_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "verified", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "dns", kind: "message", T: () => DomainGetReply_Domain_DNS }
        ]);
    }
    create(value?: PartialMessage<DomainGetReply_Domain>): DomainGetReply_Domain {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.domainId = "";
        message.name = "";
        message.verified = false;
        if (value !== undefined)
            reflectionMergePartial<DomainGetReply_Domain>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DomainGetReply_Domain): DomainGetReply_Domain {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain_id */ 1:
                    message.domainId = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* bool verified */ 3:
                    message.verified = reader.bool();
                    break;
                case /* DomainGetReply.Domain.DNS dns */ 4:
                    message.dns = DomainGetReply_Domain_DNS.internalBinaryRead(reader, reader.uint32(), options, message.dns);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DomainGetReply_Domain, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain_id = 1; */
        if (message.domainId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domainId);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* bool verified = 3; */
        if (message.verified !== false)
            writer.tag(3, WireType.Varint).bool(message.verified);
        /* DomainGetReply.Domain.DNS dns = 4; */
        if (message.dns)
            DomainGetReply_Domain_DNS.internalBinaryWrite(message.dns, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DomainGetReply.Domain
 */
export const DomainGetReply_Domain = new DomainGetReply_Domain$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DomainGetReply_Domain_DNS$Type extends MessageType<DomainGetReply_Domain_DNS> {
    constructor() {
        super("DomainGetReply.Domain.DNS", [
            { no: 1, name: "misconfigured", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "verified", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "missing_records", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DomainGetReply_Domain_DNS_MissingRecord },
            { no: 4, name: "required_verifications", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DomainGetReply_Domain_DNS_RequiredVerification }
        ]);
    }
    create(value?: PartialMessage<DomainGetReply_Domain_DNS>): DomainGetReply_Domain_DNS {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.misconfigured = false;
        message.verified = false;
        message.missingRecords = [];
        message.requiredVerifications = [];
        if (value !== undefined)
            reflectionMergePartial<DomainGetReply_Domain_DNS>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DomainGetReply_Domain_DNS): DomainGetReply_Domain_DNS {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool misconfigured */ 1:
                    message.misconfigured = reader.bool();
                    break;
                case /* bool verified */ 2:
                    message.verified = reader.bool();
                    break;
                case /* repeated DomainGetReply.Domain.DNS.MissingRecord missing_records */ 3:
                    message.missingRecords.push(DomainGetReply_Domain_DNS_MissingRecord.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated DomainGetReply.Domain.DNS.RequiredVerification required_verifications */ 4:
                    message.requiredVerifications.push(DomainGetReply_Domain_DNS_RequiredVerification.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DomainGetReply_Domain_DNS, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool misconfigured = 1; */
        if (message.misconfigured !== false)
            writer.tag(1, WireType.Varint).bool(message.misconfigured);
        /* bool verified = 2; */
        if (message.verified !== false)
            writer.tag(2, WireType.Varint).bool(message.verified);
        /* repeated DomainGetReply.Domain.DNS.MissingRecord missing_records = 3; */
        for (let i = 0; i < message.missingRecords.length; i++)
            DomainGetReply_Domain_DNS_MissingRecord.internalBinaryWrite(message.missingRecords[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated DomainGetReply.Domain.DNS.RequiredVerification required_verifications = 4; */
        for (let i = 0; i < message.requiredVerifications.length; i++)
            DomainGetReply_Domain_DNS_RequiredVerification.internalBinaryWrite(message.requiredVerifications[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DomainGetReply.Domain.DNS
 */
export const DomainGetReply_Domain_DNS = new DomainGetReply_Domain_DNS$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DomainGetReply_Domain_DNS_MissingRecord$Type extends MessageType<DomainGetReply_Domain_DNS_MissingRecord> {
    constructor() {
        super("DomainGetReply.Domain.DNS.MissingRecord", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DomainGetReply_Domain_DNS_MissingRecord>): DomainGetReply_Domain_DNS_MissingRecord {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.name = "";
        message.value = "";
        if (value !== undefined)
            reflectionMergePartial<DomainGetReply_Domain_DNS_MissingRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DomainGetReply_Domain_DNS_MissingRecord): DomainGetReply_Domain_DNS_MissingRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string value */ 3:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DomainGetReply_Domain_DNS_MissingRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string value = 3; */
        if (message.value !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DomainGetReply.Domain.DNS.MissingRecord
 */
export const DomainGetReply_Domain_DNS_MissingRecord = new DomainGetReply_Domain_DNS_MissingRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DomainGetReply_Domain_DNS_RequiredVerification$Type extends MessageType<DomainGetReply_Domain_DNS_RequiredVerification> {
    constructor() {
        super("DomainGetReply.Domain.DNS.RequiredVerification", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DomainGetReply_Domain_DNS_RequiredVerification>): DomainGetReply_Domain_DNS_RequiredVerification {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.domain = "";
        message.value = "";
        if (value !== undefined)
            reflectionMergePartial<DomainGetReply_Domain_DNS_RequiredVerification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DomainGetReply_Domain_DNS_RequiredVerification): DomainGetReply_Domain_DNS_RequiredVerification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string domain */ 2:
                    message.domain = reader.string();
                    break;
                case /* string value */ 3:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DomainGetReply_Domain_DNS_RequiredVerification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string domain = 2; */
        if (message.domain !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.domain);
        /* string value = 3; */
        if (message.value !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DomainGetReply.Domain.DNS.RequiredVerification
 */
export const DomainGetReply_Domain_DNS_RequiredVerification = new DomainGetReply_Domain_DNS_RequiredVerification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DomainCreateRequest$Type extends MessageType<DomainCreateRequest> {
    constructor() {
        super("DomainCreateRequest", [
            { no: 1, name: "domain_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DomainCreateRequest>): DomainCreateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.domainName = "";
        if (value !== undefined)
            reflectionMergePartial<DomainCreateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DomainCreateRequest): DomainCreateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain_name */ 1:
                    message.domainName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DomainCreateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain_name = 1; */
        if (message.domainName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domainName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DomainCreateRequest
 */
export const DomainCreateRequest = new DomainCreateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DomainCreateReply$Type extends MessageType<DomainCreateReply> {
    constructor() {
        super("DomainCreateReply", []);
    }
    create(value?: PartialMessage<DomainCreateReply>): DomainCreateReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DomainCreateReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DomainCreateReply): DomainCreateReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DomainCreateReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DomainCreateReply
 */
export const DomainCreateReply = new DomainCreateReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DomainDeleteRequest$Type extends MessageType<DomainDeleteRequest> {
    constructor() {
        super("DomainDeleteRequest", [
            { no: 1, name: "domain_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DomainDeleteRequest>): DomainDeleteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.domainId = "";
        if (value !== undefined)
            reflectionMergePartial<DomainDeleteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DomainDeleteRequest): DomainDeleteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain_id */ 1:
                    message.domainId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DomainDeleteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain_id = 1; */
        if (message.domainId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domainId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DomainDeleteRequest
 */
export const DomainDeleteRequest = new DomainDeleteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DomainDeleteReply$Type extends MessageType<DomainDeleteReply> {
    constructor() {
        super("DomainDeleteReply", []);
    }
    create(value?: PartialMessage<DomainDeleteReply>): DomainDeleteReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DomainDeleteReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DomainDeleteReply): DomainDeleteReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DomainDeleteReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DomainDeleteReply
 */
export const DomainDeleteReply = new DomainDeleteReply$Type();
/**
 * @generated ServiceType for protobuf service DomainService
 */
export const DomainService = new ServiceType("DomainService", [
    { name: "DomainGet", options: {}, I: DomainGetRequest, O: DomainGetReply },
    { name: "DomainCreate", options: {}, I: DomainCreateRequest, O: DomainCreateReply },
    { name: "DomainDelete", options: {}, I: DomainDeleteRequest, O: DomainDeleteReply }
]);
