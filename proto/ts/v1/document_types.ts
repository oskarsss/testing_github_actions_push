// @generated by protobuf-ts 2.9.4 with parameter long_type_number,generate_dependencies,ts_nocheck,output_typescript
// @generated from protobuf file "v1/document_types.proto" (syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { DocumentModel_DocumentEntityType } from "./models/model_document";
import { DocumentModel_Type } from "./models/model_document";
/**
 * DocumentTypeGet
 *
 * @generated from protobuf message DocumentTypeGetRequest
 */
export interface DocumentTypeGetRequest {
}
/**
 * @generated from protobuf message DocumentTypeGetReply
 */
export interface DocumentTypeGetReply {
    /**
     * @generated from protobuf field: repeated DocumentModel.Type document_types = 1;
     */
    documentTypes: DocumentModel_Type[];
}
/**
 * DocumentTypeCreate
 *
 * @generated from protobuf message DocumentTypeCreateRequest
 */
export interface DocumentTypeCreateRequest {
    /**
     * @generated from protobuf field: string title = 1;
     */
    title: string;
    /**
     * @generated from protobuf field: DocumentModel.DocumentEntityType entity_type = 2;
     */
    entityType: DocumentModel_DocumentEntityType;
    /**
     * @generated from protobuf field: DocumentTypeCreateRequest.State state = 3;
     */
    state?: DocumentTypeCreateRequest_State;
    /**
     * @generated from protobuf field: DocumentTypeCreateRequest.Country country = 4;
     */
    country?: DocumentTypeCreateRequest_Country;
    /**
     * @generated from protobuf field: bool expirable = 5;
     */
    expirable: boolean;
    /**
     * @generated from protobuf field: bool number_supported = 6;
     */
    numberSupported: boolean;
    /**
     * @generated from protobuf field: bool status_supported = 7;
     */
    statusSupported: boolean;
    /**
     * @generated from protobuf field: bool required = 8;
     */
    required: boolean;
    /**
     * @generated from protobuf field: bool can_driver_update = 9;
     */
    canDriverUpdate: boolean;
    /**
     * @generated from protobuf field: bool can_driver_view = 10;
     */
    canDriverView: boolean;
}
/**
 * @generated from protobuf message DocumentTypeCreateRequest.State
 */
export interface DocumentTypeCreateRequest_State {
    /**
     * @generated from protobuf field: bool supported = 1;
     */
    supported: boolean;
    /**
     * @generated from protobuf field: string default = 2;
     */
    default: string;
}
/**
 * @generated from protobuf message DocumentTypeCreateRequest.Country
 */
export interface DocumentTypeCreateRequest_Country {
    /**
     * @generated from protobuf field: bool supported = 1;
     */
    supported: boolean;
    /**
     * @generated from protobuf field: string default = 2;
     */
    default: string;
}
/**
 * @generated from protobuf message DocumentTypeCreateReply
 */
export interface DocumentTypeCreateReply {
    /**
     * @generated from protobuf field: string document_type_id = 1;
     */
    documentTypeId: string;
}
/**
 * DocumentTypeUpdate
 *
 * @generated from protobuf message DocumentTypeUpdateRequest
 */
export interface DocumentTypeUpdateRequest {
    /**
     * @generated from protobuf field: string document_type_id = 1;
     */
    documentTypeId: string;
    /**
     * @generated from protobuf field: string title = 2;
     */
    title: string;
    /**
     * @generated from protobuf field: DocumentModel.DocumentEntityType entity_type = 3;
     */
    entityType: DocumentModel_DocumentEntityType;
    /**
     * @generated from protobuf field: DocumentTypeUpdateRequest.State state = 4;
     */
    state?: DocumentTypeUpdateRequest_State;
    /**
     * @generated from protobuf field: DocumentTypeUpdateRequest.Country country = 5;
     */
    country?: DocumentTypeUpdateRequest_Country;
    /**
     * @generated from protobuf field: bool expirable = 6;
     */
    expirable: boolean;
    /**
     * @generated from protobuf field: bool number_supported = 7;
     */
    numberSupported: boolean;
    /**
     * @generated from protobuf field: bool status_supported = 8;
     */
    statusSupported: boolean;
    /**
     * @generated from protobuf field: bool required = 9;
     */
    required: boolean;
    /**
     * @generated from protobuf field: bool can_driver_update = 10;
     */
    canDriverUpdate: boolean;
    /**
     * @generated from protobuf field: bool can_driver_view = 11;
     */
    canDriverView: boolean;
}
/**
 * @generated from protobuf message DocumentTypeUpdateRequest.State
 */
export interface DocumentTypeUpdateRequest_State {
    /**
     * @generated from protobuf field: bool supported = 1;
     */
    supported: boolean;
    /**
     * @generated from protobuf field: string default = 2;
     */
    default: string;
}
/**
 * @generated from protobuf message DocumentTypeUpdateRequest.Country
 */
export interface DocumentTypeUpdateRequest_Country {
    /**
     * @generated from protobuf field: bool supported = 1;
     */
    supported: boolean;
    /**
     * @generated from protobuf field: string default = 2;
     */
    default: string;
}
/**
 * @generated from protobuf message DocumentTypeUpdateReply
 */
export interface DocumentTypeUpdateReply {
}
/**
 * DocumentTypeDelete
 *
 * @generated from protobuf message DocumentTypeDeleteRequest
 */
export interface DocumentTypeDeleteRequest {
    /**
     * @generated from protobuf field: string document_type_id = 1;
     */
    documentTypeId: string;
}
/**
 * @generated from protobuf message DocumentTypeDeleteReply
 */
export interface DocumentTypeDeleteReply {
}
/**
 * DocumentTypeSequenceUpdate
 *
 * @generated from protobuf message DocumentTypeSequenceUpdateRequest
 */
export interface DocumentTypeSequenceUpdateRequest {
    /**
     * @generated from protobuf field: repeated DocumentTypeSequenceUpdateRequest.DocumentTypeSequence document_type_sequences = 1;
     */
    documentTypeSequences: DocumentTypeSequenceUpdateRequest_DocumentTypeSequence[];
}
/**
 * @generated from protobuf message DocumentTypeSequenceUpdateRequest.DocumentTypeSequence
 */
export interface DocumentTypeSequenceUpdateRequest_DocumentTypeSequence {
    /**
     * @generated from protobuf field: string document_type_id = 1;
     */
    documentTypeId: string;
    /**
     * @generated from protobuf field: int64 sequence = 2;
     */
    sequence: number;
}
/**
 * @generated from protobuf message DocumentTypeSequenceUpdateReply
 */
export interface DocumentTypeSequenceUpdateReply {
}
// @generated message type with reflection information, may provide speed optimized methods
class DocumentTypeGetRequest$Type extends MessageType<DocumentTypeGetRequest> {
    constructor() {
        super("DocumentTypeGetRequest", []);
    }
    create(value?: PartialMessage<DocumentTypeGetRequest>): DocumentTypeGetRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DocumentTypeGetRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentTypeGetRequest): DocumentTypeGetRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DocumentTypeGetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentTypeGetRequest
 */
export const DocumentTypeGetRequest = new DocumentTypeGetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentTypeGetReply$Type extends MessageType<DocumentTypeGetReply> {
    constructor() {
        super("DocumentTypeGetReply", [
            { no: 1, name: "document_types", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DocumentModel_Type }
        ]);
    }
    create(value?: PartialMessage<DocumentTypeGetReply>): DocumentTypeGetReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.documentTypes = [];
        if (value !== undefined)
            reflectionMergePartial<DocumentTypeGetReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentTypeGetReply): DocumentTypeGetReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated DocumentModel.Type document_types */ 1:
                    message.documentTypes.push(DocumentModel_Type.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentTypeGetReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated DocumentModel.Type document_types = 1; */
        for (let i = 0; i < message.documentTypes.length; i++)
            DocumentModel_Type.internalBinaryWrite(message.documentTypes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentTypeGetReply
 */
export const DocumentTypeGetReply = new DocumentTypeGetReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentTypeCreateRequest$Type extends MessageType<DocumentTypeCreateRequest> {
    constructor() {
        super("DocumentTypeCreateRequest", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "entity_type", kind: "enum", T: () => ["DocumentModel.DocumentEntityType", DocumentModel_DocumentEntityType, "DOCUMENT_ENTITY_TYPE_"] },
            { no: 3, name: "state", kind: "message", T: () => DocumentTypeCreateRequest_State },
            { no: 4, name: "country", kind: "message", T: () => DocumentTypeCreateRequest_Country },
            { no: 5, name: "expirable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "number_supported", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "status_supported", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "required", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "can_driver_update", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "can_driver_view", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentTypeCreateRequest>): DocumentTypeCreateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.title = "";
        message.entityType = 0;
        message.expirable = false;
        message.numberSupported = false;
        message.statusSupported = false;
        message.required = false;
        message.canDriverUpdate = false;
        message.canDriverView = false;
        if (value !== undefined)
            reflectionMergePartial<DocumentTypeCreateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentTypeCreateRequest): DocumentTypeCreateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* DocumentModel.DocumentEntityType entity_type */ 2:
                    message.entityType = reader.int32();
                    break;
                case /* DocumentTypeCreateRequest.State state */ 3:
                    message.state = DocumentTypeCreateRequest_State.internalBinaryRead(reader, reader.uint32(), options, message.state);
                    break;
                case /* DocumentTypeCreateRequest.Country country */ 4:
                    message.country = DocumentTypeCreateRequest_Country.internalBinaryRead(reader, reader.uint32(), options, message.country);
                    break;
                case /* bool expirable */ 5:
                    message.expirable = reader.bool();
                    break;
                case /* bool number_supported */ 6:
                    message.numberSupported = reader.bool();
                    break;
                case /* bool status_supported */ 7:
                    message.statusSupported = reader.bool();
                    break;
                case /* bool required */ 8:
                    message.required = reader.bool();
                    break;
                case /* bool can_driver_update */ 9:
                    message.canDriverUpdate = reader.bool();
                    break;
                case /* bool can_driver_view */ 10:
                    message.canDriverView = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentTypeCreateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* DocumentModel.DocumentEntityType entity_type = 2; */
        if (message.entityType !== 0)
            writer.tag(2, WireType.Varint).int32(message.entityType);
        /* DocumentTypeCreateRequest.State state = 3; */
        if (message.state)
            DocumentTypeCreateRequest_State.internalBinaryWrite(message.state, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* DocumentTypeCreateRequest.Country country = 4; */
        if (message.country)
            DocumentTypeCreateRequest_Country.internalBinaryWrite(message.country, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool expirable = 5; */
        if (message.expirable !== false)
            writer.tag(5, WireType.Varint).bool(message.expirable);
        /* bool number_supported = 6; */
        if (message.numberSupported !== false)
            writer.tag(6, WireType.Varint).bool(message.numberSupported);
        /* bool status_supported = 7; */
        if (message.statusSupported !== false)
            writer.tag(7, WireType.Varint).bool(message.statusSupported);
        /* bool required = 8; */
        if (message.required !== false)
            writer.tag(8, WireType.Varint).bool(message.required);
        /* bool can_driver_update = 9; */
        if (message.canDriverUpdate !== false)
            writer.tag(9, WireType.Varint).bool(message.canDriverUpdate);
        /* bool can_driver_view = 10; */
        if (message.canDriverView !== false)
            writer.tag(10, WireType.Varint).bool(message.canDriverView);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentTypeCreateRequest
 */
export const DocumentTypeCreateRequest = new DocumentTypeCreateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentTypeCreateRequest_State$Type extends MessageType<DocumentTypeCreateRequest_State> {
    constructor() {
        super("DocumentTypeCreateRequest.State", [
            { no: 1, name: "supported", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "default", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentTypeCreateRequest_State>): DocumentTypeCreateRequest_State {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.supported = false;
        message.default = "";
        if (value !== undefined)
            reflectionMergePartial<DocumentTypeCreateRequest_State>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentTypeCreateRequest_State): DocumentTypeCreateRequest_State {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool supported */ 1:
                    message.supported = reader.bool();
                    break;
                case /* string default */ 2:
                    message.default = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentTypeCreateRequest_State, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool supported = 1; */
        if (message.supported !== false)
            writer.tag(1, WireType.Varint).bool(message.supported);
        /* string default = 2; */
        if (message.default !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.default);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentTypeCreateRequest.State
 */
export const DocumentTypeCreateRequest_State = new DocumentTypeCreateRequest_State$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentTypeCreateRequest_Country$Type extends MessageType<DocumentTypeCreateRequest_Country> {
    constructor() {
        super("DocumentTypeCreateRequest.Country", [
            { no: 1, name: "supported", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "default", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentTypeCreateRequest_Country>): DocumentTypeCreateRequest_Country {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.supported = false;
        message.default = "";
        if (value !== undefined)
            reflectionMergePartial<DocumentTypeCreateRequest_Country>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentTypeCreateRequest_Country): DocumentTypeCreateRequest_Country {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool supported */ 1:
                    message.supported = reader.bool();
                    break;
                case /* string default */ 2:
                    message.default = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentTypeCreateRequest_Country, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool supported = 1; */
        if (message.supported !== false)
            writer.tag(1, WireType.Varint).bool(message.supported);
        /* string default = 2; */
        if (message.default !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.default);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentTypeCreateRequest.Country
 */
export const DocumentTypeCreateRequest_Country = new DocumentTypeCreateRequest_Country$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentTypeCreateReply$Type extends MessageType<DocumentTypeCreateReply> {
    constructor() {
        super("DocumentTypeCreateReply", [
            { no: 1, name: "document_type_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentTypeCreateReply>): DocumentTypeCreateReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.documentTypeId = "";
        if (value !== undefined)
            reflectionMergePartial<DocumentTypeCreateReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentTypeCreateReply): DocumentTypeCreateReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string document_type_id */ 1:
                    message.documentTypeId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentTypeCreateReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string document_type_id = 1; */
        if (message.documentTypeId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.documentTypeId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentTypeCreateReply
 */
export const DocumentTypeCreateReply = new DocumentTypeCreateReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentTypeUpdateRequest$Type extends MessageType<DocumentTypeUpdateRequest> {
    constructor() {
        super("DocumentTypeUpdateRequest", [
            { no: 1, name: "document_type_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "entity_type", kind: "enum", T: () => ["DocumentModel.DocumentEntityType", DocumentModel_DocumentEntityType, "DOCUMENT_ENTITY_TYPE_"] },
            { no: 4, name: "state", kind: "message", T: () => DocumentTypeUpdateRequest_State },
            { no: 5, name: "country", kind: "message", T: () => DocumentTypeUpdateRequest_Country },
            { no: 6, name: "expirable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "number_supported", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "status_supported", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "required", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "can_driver_update", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "can_driver_view", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentTypeUpdateRequest>): DocumentTypeUpdateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.documentTypeId = "";
        message.title = "";
        message.entityType = 0;
        message.expirable = false;
        message.numberSupported = false;
        message.statusSupported = false;
        message.required = false;
        message.canDriverUpdate = false;
        message.canDriverView = false;
        if (value !== undefined)
            reflectionMergePartial<DocumentTypeUpdateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentTypeUpdateRequest): DocumentTypeUpdateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string document_type_id */ 1:
                    message.documentTypeId = reader.string();
                    break;
                case /* string title */ 2:
                    message.title = reader.string();
                    break;
                case /* DocumentModel.DocumentEntityType entity_type */ 3:
                    message.entityType = reader.int32();
                    break;
                case /* DocumentTypeUpdateRequest.State state */ 4:
                    message.state = DocumentTypeUpdateRequest_State.internalBinaryRead(reader, reader.uint32(), options, message.state);
                    break;
                case /* DocumentTypeUpdateRequest.Country country */ 5:
                    message.country = DocumentTypeUpdateRequest_Country.internalBinaryRead(reader, reader.uint32(), options, message.country);
                    break;
                case /* bool expirable */ 6:
                    message.expirable = reader.bool();
                    break;
                case /* bool number_supported */ 7:
                    message.numberSupported = reader.bool();
                    break;
                case /* bool status_supported */ 8:
                    message.statusSupported = reader.bool();
                    break;
                case /* bool required */ 9:
                    message.required = reader.bool();
                    break;
                case /* bool can_driver_update */ 10:
                    message.canDriverUpdate = reader.bool();
                    break;
                case /* bool can_driver_view */ 11:
                    message.canDriverView = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentTypeUpdateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string document_type_id = 1; */
        if (message.documentTypeId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.documentTypeId);
        /* string title = 2; */
        if (message.title !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.title);
        /* DocumentModel.DocumentEntityType entity_type = 3; */
        if (message.entityType !== 0)
            writer.tag(3, WireType.Varint).int32(message.entityType);
        /* DocumentTypeUpdateRequest.State state = 4; */
        if (message.state)
            DocumentTypeUpdateRequest_State.internalBinaryWrite(message.state, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* DocumentTypeUpdateRequest.Country country = 5; */
        if (message.country)
            DocumentTypeUpdateRequest_Country.internalBinaryWrite(message.country, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bool expirable = 6; */
        if (message.expirable !== false)
            writer.tag(6, WireType.Varint).bool(message.expirable);
        /* bool number_supported = 7; */
        if (message.numberSupported !== false)
            writer.tag(7, WireType.Varint).bool(message.numberSupported);
        /* bool status_supported = 8; */
        if (message.statusSupported !== false)
            writer.tag(8, WireType.Varint).bool(message.statusSupported);
        /* bool required = 9; */
        if (message.required !== false)
            writer.tag(9, WireType.Varint).bool(message.required);
        /* bool can_driver_update = 10; */
        if (message.canDriverUpdate !== false)
            writer.tag(10, WireType.Varint).bool(message.canDriverUpdate);
        /* bool can_driver_view = 11; */
        if (message.canDriverView !== false)
            writer.tag(11, WireType.Varint).bool(message.canDriverView);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentTypeUpdateRequest
 */
export const DocumentTypeUpdateRequest = new DocumentTypeUpdateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentTypeUpdateRequest_State$Type extends MessageType<DocumentTypeUpdateRequest_State> {
    constructor() {
        super("DocumentTypeUpdateRequest.State", [
            { no: 1, name: "supported", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "default", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentTypeUpdateRequest_State>): DocumentTypeUpdateRequest_State {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.supported = false;
        message.default = "";
        if (value !== undefined)
            reflectionMergePartial<DocumentTypeUpdateRequest_State>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentTypeUpdateRequest_State): DocumentTypeUpdateRequest_State {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool supported */ 1:
                    message.supported = reader.bool();
                    break;
                case /* string default */ 2:
                    message.default = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentTypeUpdateRequest_State, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool supported = 1; */
        if (message.supported !== false)
            writer.tag(1, WireType.Varint).bool(message.supported);
        /* string default = 2; */
        if (message.default !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.default);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentTypeUpdateRequest.State
 */
export const DocumentTypeUpdateRequest_State = new DocumentTypeUpdateRequest_State$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentTypeUpdateRequest_Country$Type extends MessageType<DocumentTypeUpdateRequest_Country> {
    constructor() {
        super("DocumentTypeUpdateRequest.Country", [
            { no: 1, name: "supported", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "default", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentTypeUpdateRequest_Country>): DocumentTypeUpdateRequest_Country {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.supported = false;
        message.default = "";
        if (value !== undefined)
            reflectionMergePartial<DocumentTypeUpdateRequest_Country>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentTypeUpdateRequest_Country): DocumentTypeUpdateRequest_Country {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool supported */ 1:
                    message.supported = reader.bool();
                    break;
                case /* string default */ 2:
                    message.default = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentTypeUpdateRequest_Country, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool supported = 1; */
        if (message.supported !== false)
            writer.tag(1, WireType.Varint).bool(message.supported);
        /* string default = 2; */
        if (message.default !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.default);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentTypeUpdateRequest.Country
 */
export const DocumentTypeUpdateRequest_Country = new DocumentTypeUpdateRequest_Country$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentTypeUpdateReply$Type extends MessageType<DocumentTypeUpdateReply> {
    constructor() {
        super("DocumentTypeUpdateReply", []);
    }
    create(value?: PartialMessage<DocumentTypeUpdateReply>): DocumentTypeUpdateReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DocumentTypeUpdateReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentTypeUpdateReply): DocumentTypeUpdateReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DocumentTypeUpdateReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentTypeUpdateReply
 */
export const DocumentTypeUpdateReply = new DocumentTypeUpdateReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentTypeDeleteRequest$Type extends MessageType<DocumentTypeDeleteRequest> {
    constructor() {
        super("DocumentTypeDeleteRequest", [
            { no: 1, name: "document_type_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentTypeDeleteRequest>): DocumentTypeDeleteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.documentTypeId = "";
        if (value !== undefined)
            reflectionMergePartial<DocumentTypeDeleteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentTypeDeleteRequest): DocumentTypeDeleteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string document_type_id */ 1:
                    message.documentTypeId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentTypeDeleteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string document_type_id = 1; */
        if (message.documentTypeId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.documentTypeId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentTypeDeleteRequest
 */
export const DocumentTypeDeleteRequest = new DocumentTypeDeleteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentTypeDeleteReply$Type extends MessageType<DocumentTypeDeleteReply> {
    constructor() {
        super("DocumentTypeDeleteReply", []);
    }
    create(value?: PartialMessage<DocumentTypeDeleteReply>): DocumentTypeDeleteReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DocumentTypeDeleteReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentTypeDeleteReply): DocumentTypeDeleteReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DocumentTypeDeleteReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentTypeDeleteReply
 */
export const DocumentTypeDeleteReply = new DocumentTypeDeleteReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentTypeSequenceUpdateRequest$Type extends MessageType<DocumentTypeSequenceUpdateRequest> {
    constructor() {
        super("DocumentTypeSequenceUpdateRequest", [
            { no: 1, name: "document_type_sequences", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DocumentTypeSequenceUpdateRequest_DocumentTypeSequence }
        ]);
    }
    create(value?: PartialMessage<DocumentTypeSequenceUpdateRequest>): DocumentTypeSequenceUpdateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.documentTypeSequences = [];
        if (value !== undefined)
            reflectionMergePartial<DocumentTypeSequenceUpdateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentTypeSequenceUpdateRequest): DocumentTypeSequenceUpdateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated DocumentTypeSequenceUpdateRequest.DocumentTypeSequence document_type_sequences */ 1:
                    message.documentTypeSequences.push(DocumentTypeSequenceUpdateRequest_DocumentTypeSequence.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentTypeSequenceUpdateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated DocumentTypeSequenceUpdateRequest.DocumentTypeSequence document_type_sequences = 1; */
        for (let i = 0; i < message.documentTypeSequences.length; i++)
            DocumentTypeSequenceUpdateRequest_DocumentTypeSequence.internalBinaryWrite(message.documentTypeSequences[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentTypeSequenceUpdateRequest
 */
export const DocumentTypeSequenceUpdateRequest = new DocumentTypeSequenceUpdateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentTypeSequenceUpdateRequest_DocumentTypeSequence$Type extends MessageType<DocumentTypeSequenceUpdateRequest_DocumentTypeSequence> {
    constructor() {
        super("DocumentTypeSequenceUpdateRequest.DocumentTypeSequence", [
            { no: 1, name: "document_type_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sequence", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentTypeSequenceUpdateRequest_DocumentTypeSequence>): DocumentTypeSequenceUpdateRequest_DocumentTypeSequence {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.documentTypeId = "";
        message.sequence = 0;
        if (value !== undefined)
            reflectionMergePartial<DocumentTypeSequenceUpdateRequest_DocumentTypeSequence>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentTypeSequenceUpdateRequest_DocumentTypeSequence): DocumentTypeSequenceUpdateRequest_DocumentTypeSequence {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string document_type_id */ 1:
                    message.documentTypeId = reader.string();
                    break;
                case /* int64 sequence */ 2:
                    message.sequence = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentTypeSequenceUpdateRequest_DocumentTypeSequence, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string document_type_id = 1; */
        if (message.documentTypeId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.documentTypeId);
        /* int64 sequence = 2; */
        if (message.sequence !== 0)
            writer.tag(2, WireType.Varint).int64(message.sequence);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentTypeSequenceUpdateRequest.DocumentTypeSequence
 */
export const DocumentTypeSequenceUpdateRequest_DocumentTypeSequence = new DocumentTypeSequenceUpdateRequest_DocumentTypeSequence$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentTypeSequenceUpdateReply$Type extends MessageType<DocumentTypeSequenceUpdateReply> {
    constructor() {
        super("DocumentTypeSequenceUpdateReply", []);
    }
    create(value?: PartialMessage<DocumentTypeSequenceUpdateReply>): DocumentTypeSequenceUpdateReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DocumentTypeSequenceUpdateReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentTypeSequenceUpdateReply): DocumentTypeSequenceUpdateReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DocumentTypeSequenceUpdateReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentTypeSequenceUpdateReply
 */
export const DocumentTypeSequenceUpdateReply = new DocumentTypeSequenceUpdateReply$Type();
/**
 * @generated ServiceType for protobuf service DocumentTypesService
 */
export const DocumentTypesService = new ServiceType("DocumentTypesService", [
    { name: "DocumentTypeGet", options: {}, I: DocumentTypeGetRequest, O: DocumentTypeGetReply },
    { name: "DocumentTypeCreate", options: {}, I: DocumentTypeCreateRequest, O: DocumentTypeCreateReply },
    { name: "DocumentTypeUpdate", options: {}, I: DocumentTypeUpdateRequest, O: DocumentTypeUpdateReply },
    { name: "DocumentTypeDelete", options: {}, I: DocumentTypeDeleteRequest, O: DocumentTypeDeleteReply },
    { name: "DocumentTypeSequenceUpdate", options: {}, I: DocumentTypeSequenceUpdateRequest, O: DocumentTypeSequenceUpdateReply }
]);
