// @generated by protobuf-ts 2.9.4 with parameter long_type_number,generate_dependencies,ts_nocheck,output_typescript
// @generated from protobuf file "v1/settlement.recurring_transaction.proto" (syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { SettlementTransactionCategoryModel_Type } from "./models/model_settlement.transaction_category";
import { Settlements_RecurringTransaction_Status } from "./models/model_settlement";
import { SettlementRecurringTransactionModel_Transaction } from "./models/model_settlement.recurring_transaction";
import { SettlementRecurringTransactionModel_DriverDetails } from "./models/model_settlement.recurring_transaction";
import { SettlementRecurringTransactionModel_RecurringTransaction } from "./models/model_settlement.recurring_transaction";
/**
 * RecurringTransactionGet
 *
 * @generated from protobuf message SettlementRecurringTransactionGetRequest
 */
export interface SettlementRecurringTransactionGetRequest {
    /**
     * @generated from protobuf field: optional string driver_id = 1;
     */
    driverId?: string;
}
/**
 * @generated from protobuf message SettlementRecurringTransactionGetReply
 */
export interface SettlementRecurringTransactionGetReply {
    /**
     * @generated from protobuf field: repeated SettlementRecurringTransactionModel.RecurringTransaction recurring_transactions = 1;
     */
    recurringTransactions: SettlementRecurringTransactionModel_RecurringTransaction[];
    /**
     * @generated from protobuf field: repeated SettlementRecurringTransactionModel.DriverDetails drivers = 2;
     */
    drivers: SettlementRecurringTransactionModel_DriverDetails[];
}
/**
 * RecurringTransactionRetrieve
 *
 * @generated from protobuf message SettlementRecurringTransactionRetrieveRequest
 */
export interface SettlementRecurringTransactionRetrieveRequest {
    /**
     * @generated from protobuf field: string recurring_transaction_id = 1;
     */
    recurringTransactionId: string;
}
/**
 * @generated from protobuf message SettlementRecurringTransactionRetrieveReply
 */
export interface SettlementRecurringTransactionRetrieveReply {
    /**
     * @generated from protobuf field: SettlementRecurringTransactionModel.RecurringTransaction recurring_transaction = 1;
     */
    recurringTransaction?: SettlementRecurringTransactionModel_RecurringTransaction;
    /**
     * @generated from protobuf field: repeated SettlementRecurringTransactionModel.Transaction transactions = 2;
     */
    transactions: SettlementRecurringTransactionModel_Transaction[];
    /**
     * @generated from protobuf field: int64 total_charged = 3;
     */
    totalCharged: number;
    /**
     * @generated from protobuf field: string total_charged_formatted = 4;
     */
    totalChargedFormatted: string;
}
/**
 * RecurringTransactionUpdate
 *
 * @generated from protobuf message SettlementRecurringTransactionUpdateRequest
 */
export interface SettlementRecurringTransactionUpdateRequest {
    /**
     * @generated from protobuf field: string recurring_transaction_id = 1;
     */
    recurringTransactionId: string;
    /**
     * @generated from protobuf field: double amount = 2;
     */
    amount: number;
    /**
     * @generated from protobuf field: string start_date = 3;
     */
    startDate: string;
    /**
     * @generated from protobuf field: string category_id = 4;
     */
    categoryId: string;
    /**
     * @generated from protobuf field: optional double max_total_amount = 5;
     */
    maxTotalAmount?: number;
    /**
     * @generated from protobuf field: optional string note = 6;
     */
    note?: string;
}
/**
 * @generated from protobuf message SettlementRecurringTransactionUpdateReply
 */
export interface SettlementRecurringTransactionUpdateReply {
    /**
     * @generated from protobuf field: string recurring_transaction_id = 1;
     */
    recurringTransactionId: string;
}
/**
 * RecurringTransactionStatusUpdate
 *
 * @generated from protobuf message SettlementRecurringTransactionStatusUpdateRequest
 */
export interface SettlementRecurringTransactionStatusUpdateRequest {
    /**
     * @generated from protobuf field: string recurring_transaction_id = 1;
     */
    recurringTransactionId: string;
    /**
     * @generated from protobuf field: Settlements.RecurringTransaction.Status status = 2;
     */
    status: Settlements_RecurringTransaction_Status;
}
/**
 * @generated from protobuf message SettlementRecurringTransactionStatusUpdateReply
 */
export interface SettlementRecurringTransactionStatusUpdateReply {
    /**
     * @generated from protobuf field: string recurring_transaction_id = 1;
     */
    recurringTransactionId: string;
}
/**
 * RecurringTransactionCreate
 *
 * @generated from protobuf message SettlementRecurringTransactionCreateRequest
 */
export interface SettlementRecurringTransactionCreateRequest {
    /**
     * @generated from protobuf field: string driver_id = 1;
     */
    driverId: string;
    /**
     * @generated from protobuf field: double amount = 2;
     */
    amount: number;
    /**
     * @generated from protobuf field: string start_date = 3;
     */
    startDate: string;
    /**
     * @generated from protobuf field: string category_id = 4;
     */
    categoryId: string;
    /**
     * @generated from protobuf field: SettlementTransactionCategoryModel.Type category_type = 5;
     */
    categoryType: SettlementTransactionCategoryModel_Type;
    /**
     * @generated from protobuf field: optional double max_total_amount = 6;
     */
    maxTotalAmount?: number;
    /**
     * @generated from protobuf field: optional string note = 7;
     */
    note?: string;
}
/**
 * @generated from protobuf message SettlementRecurringTransactionCreateReply
 */
export interface SettlementRecurringTransactionCreateReply {
    /**
     * @generated from protobuf field: string recurring_transaction_id = 1;
     */
    recurringTransactionId: string;
}
/**
 * RecurringTransactionDelete
 *
 * @generated from protobuf message SettlementRecurringTransactionDeleteRequest
 */
export interface SettlementRecurringTransactionDeleteRequest {
    /**
     * @generated from protobuf field: string recurring_transaction_id = 1;
     */
    recurringTransactionId: string;
}
/**
 * @generated from protobuf message SettlementRecurringTransactionDeleteReply
 */
export interface SettlementRecurringTransactionDeleteReply {
}
// @generated message type with reflection information, may provide speed optimized methods
class SettlementRecurringTransactionGetRequest$Type extends MessageType<SettlementRecurringTransactionGetRequest> {
    constructor() {
        super("SettlementRecurringTransactionGetRequest", [
            { no: 1, name: "driver_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SettlementRecurringTransactionGetRequest>): SettlementRecurringTransactionGetRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SettlementRecurringTransactionGetRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SettlementRecurringTransactionGetRequest): SettlementRecurringTransactionGetRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string driver_id */ 1:
                    message.driverId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SettlementRecurringTransactionGetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string driver_id = 1; */
        if (message.driverId !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.driverId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SettlementRecurringTransactionGetRequest
 */
export const SettlementRecurringTransactionGetRequest = new SettlementRecurringTransactionGetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SettlementRecurringTransactionGetReply$Type extends MessageType<SettlementRecurringTransactionGetReply> {
    constructor() {
        super("SettlementRecurringTransactionGetReply", [
            { no: 1, name: "recurring_transactions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SettlementRecurringTransactionModel_RecurringTransaction },
            { no: 2, name: "drivers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SettlementRecurringTransactionModel_DriverDetails }
        ]);
    }
    create(value?: PartialMessage<SettlementRecurringTransactionGetReply>): SettlementRecurringTransactionGetReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.recurringTransactions = [];
        message.drivers = [];
        if (value !== undefined)
            reflectionMergePartial<SettlementRecurringTransactionGetReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SettlementRecurringTransactionGetReply): SettlementRecurringTransactionGetReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated SettlementRecurringTransactionModel.RecurringTransaction recurring_transactions */ 1:
                    message.recurringTransactions.push(SettlementRecurringTransactionModel_RecurringTransaction.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated SettlementRecurringTransactionModel.DriverDetails drivers */ 2:
                    message.drivers.push(SettlementRecurringTransactionModel_DriverDetails.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SettlementRecurringTransactionGetReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated SettlementRecurringTransactionModel.RecurringTransaction recurring_transactions = 1; */
        for (let i = 0; i < message.recurringTransactions.length; i++)
            SettlementRecurringTransactionModel_RecurringTransaction.internalBinaryWrite(message.recurringTransactions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated SettlementRecurringTransactionModel.DriverDetails drivers = 2; */
        for (let i = 0; i < message.drivers.length; i++)
            SettlementRecurringTransactionModel_DriverDetails.internalBinaryWrite(message.drivers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SettlementRecurringTransactionGetReply
 */
export const SettlementRecurringTransactionGetReply = new SettlementRecurringTransactionGetReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SettlementRecurringTransactionRetrieveRequest$Type extends MessageType<SettlementRecurringTransactionRetrieveRequest> {
    constructor() {
        super("SettlementRecurringTransactionRetrieveRequest", [
            { no: 1, name: "recurring_transaction_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SettlementRecurringTransactionRetrieveRequest>): SettlementRecurringTransactionRetrieveRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.recurringTransactionId = "";
        if (value !== undefined)
            reflectionMergePartial<SettlementRecurringTransactionRetrieveRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SettlementRecurringTransactionRetrieveRequest): SettlementRecurringTransactionRetrieveRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string recurring_transaction_id */ 1:
                    message.recurringTransactionId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SettlementRecurringTransactionRetrieveRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string recurring_transaction_id = 1; */
        if (message.recurringTransactionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.recurringTransactionId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SettlementRecurringTransactionRetrieveRequest
 */
export const SettlementRecurringTransactionRetrieveRequest = new SettlementRecurringTransactionRetrieveRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SettlementRecurringTransactionRetrieveReply$Type extends MessageType<SettlementRecurringTransactionRetrieveReply> {
    constructor() {
        super("SettlementRecurringTransactionRetrieveReply", [
            { no: 1, name: "recurring_transaction", kind: "message", T: () => SettlementRecurringTransactionModel_RecurringTransaction },
            { no: 2, name: "transactions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SettlementRecurringTransactionModel_Transaction },
            { no: 3, name: "total_charged", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "total_charged_formatted", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SettlementRecurringTransactionRetrieveReply>): SettlementRecurringTransactionRetrieveReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transactions = [];
        message.totalCharged = 0;
        message.totalChargedFormatted = "";
        if (value !== undefined)
            reflectionMergePartial<SettlementRecurringTransactionRetrieveReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SettlementRecurringTransactionRetrieveReply): SettlementRecurringTransactionRetrieveReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* SettlementRecurringTransactionModel.RecurringTransaction recurring_transaction */ 1:
                    message.recurringTransaction = SettlementRecurringTransactionModel_RecurringTransaction.internalBinaryRead(reader, reader.uint32(), options, message.recurringTransaction);
                    break;
                case /* repeated SettlementRecurringTransactionModel.Transaction transactions */ 2:
                    message.transactions.push(SettlementRecurringTransactionModel_Transaction.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int64 total_charged */ 3:
                    message.totalCharged = reader.int64().toNumber();
                    break;
                case /* string total_charged_formatted */ 4:
                    message.totalChargedFormatted = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SettlementRecurringTransactionRetrieveReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* SettlementRecurringTransactionModel.RecurringTransaction recurring_transaction = 1; */
        if (message.recurringTransaction)
            SettlementRecurringTransactionModel_RecurringTransaction.internalBinaryWrite(message.recurringTransaction, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated SettlementRecurringTransactionModel.Transaction transactions = 2; */
        for (let i = 0; i < message.transactions.length; i++)
            SettlementRecurringTransactionModel_Transaction.internalBinaryWrite(message.transactions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int64 total_charged = 3; */
        if (message.totalCharged !== 0)
            writer.tag(3, WireType.Varint).int64(message.totalCharged);
        /* string total_charged_formatted = 4; */
        if (message.totalChargedFormatted !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.totalChargedFormatted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SettlementRecurringTransactionRetrieveReply
 */
export const SettlementRecurringTransactionRetrieveReply = new SettlementRecurringTransactionRetrieveReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SettlementRecurringTransactionUpdateRequest$Type extends MessageType<SettlementRecurringTransactionUpdateRequest> {
    constructor() {
        super("SettlementRecurringTransactionUpdateRequest", [
            { no: 1, name: "recurring_transaction_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "amount", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "start_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "category_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "max_total_amount", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "note", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SettlementRecurringTransactionUpdateRequest>): SettlementRecurringTransactionUpdateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.recurringTransactionId = "";
        message.amount = 0;
        message.startDate = "";
        message.categoryId = "";
        if (value !== undefined)
            reflectionMergePartial<SettlementRecurringTransactionUpdateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SettlementRecurringTransactionUpdateRequest): SettlementRecurringTransactionUpdateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string recurring_transaction_id */ 1:
                    message.recurringTransactionId = reader.string();
                    break;
                case /* double amount */ 2:
                    message.amount = reader.double();
                    break;
                case /* string start_date */ 3:
                    message.startDate = reader.string();
                    break;
                case /* string category_id */ 4:
                    message.categoryId = reader.string();
                    break;
                case /* optional double max_total_amount */ 5:
                    message.maxTotalAmount = reader.double();
                    break;
                case /* optional string note */ 6:
                    message.note = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SettlementRecurringTransactionUpdateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string recurring_transaction_id = 1; */
        if (message.recurringTransactionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.recurringTransactionId);
        /* double amount = 2; */
        if (message.amount !== 0)
            writer.tag(2, WireType.Bit64).double(message.amount);
        /* string start_date = 3; */
        if (message.startDate !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.startDate);
        /* string category_id = 4; */
        if (message.categoryId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.categoryId);
        /* optional double max_total_amount = 5; */
        if (message.maxTotalAmount !== undefined)
            writer.tag(5, WireType.Bit64).double(message.maxTotalAmount);
        /* optional string note = 6; */
        if (message.note !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.note);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SettlementRecurringTransactionUpdateRequest
 */
export const SettlementRecurringTransactionUpdateRequest = new SettlementRecurringTransactionUpdateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SettlementRecurringTransactionUpdateReply$Type extends MessageType<SettlementRecurringTransactionUpdateReply> {
    constructor() {
        super("SettlementRecurringTransactionUpdateReply", [
            { no: 1, name: "recurring_transaction_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SettlementRecurringTransactionUpdateReply>): SettlementRecurringTransactionUpdateReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.recurringTransactionId = "";
        if (value !== undefined)
            reflectionMergePartial<SettlementRecurringTransactionUpdateReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SettlementRecurringTransactionUpdateReply): SettlementRecurringTransactionUpdateReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string recurring_transaction_id */ 1:
                    message.recurringTransactionId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SettlementRecurringTransactionUpdateReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string recurring_transaction_id = 1; */
        if (message.recurringTransactionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.recurringTransactionId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SettlementRecurringTransactionUpdateReply
 */
export const SettlementRecurringTransactionUpdateReply = new SettlementRecurringTransactionUpdateReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SettlementRecurringTransactionStatusUpdateRequest$Type extends MessageType<SettlementRecurringTransactionStatusUpdateRequest> {
    constructor() {
        super("SettlementRecurringTransactionStatusUpdateRequest", [
            { no: 1, name: "recurring_transaction_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "status", kind: "enum", T: () => ["Settlements.RecurringTransaction.Status", Settlements_RecurringTransaction_Status] }
        ]);
    }
    create(value?: PartialMessage<SettlementRecurringTransactionStatusUpdateRequest>): SettlementRecurringTransactionStatusUpdateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.recurringTransactionId = "";
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial<SettlementRecurringTransactionStatusUpdateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SettlementRecurringTransactionStatusUpdateRequest): SettlementRecurringTransactionStatusUpdateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string recurring_transaction_id */ 1:
                    message.recurringTransactionId = reader.string();
                    break;
                case /* Settlements.RecurringTransaction.Status status */ 2:
                    message.status = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SettlementRecurringTransactionStatusUpdateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string recurring_transaction_id = 1; */
        if (message.recurringTransactionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.recurringTransactionId);
        /* Settlements.RecurringTransaction.Status status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).int32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SettlementRecurringTransactionStatusUpdateRequest
 */
export const SettlementRecurringTransactionStatusUpdateRequest = new SettlementRecurringTransactionStatusUpdateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SettlementRecurringTransactionStatusUpdateReply$Type extends MessageType<SettlementRecurringTransactionStatusUpdateReply> {
    constructor() {
        super("SettlementRecurringTransactionStatusUpdateReply", [
            { no: 1, name: "recurring_transaction_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SettlementRecurringTransactionStatusUpdateReply>): SettlementRecurringTransactionStatusUpdateReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.recurringTransactionId = "";
        if (value !== undefined)
            reflectionMergePartial<SettlementRecurringTransactionStatusUpdateReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SettlementRecurringTransactionStatusUpdateReply): SettlementRecurringTransactionStatusUpdateReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string recurring_transaction_id */ 1:
                    message.recurringTransactionId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SettlementRecurringTransactionStatusUpdateReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string recurring_transaction_id = 1; */
        if (message.recurringTransactionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.recurringTransactionId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SettlementRecurringTransactionStatusUpdateReply
 */
export const SettlementRecurringTransactionStatusUpdateReply = new SettlementRecurringTransactionStatusUpdateReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SettlementRecurringTransactionCreateRequest$Type extends MessageType<SettlementRecurringTransactionCreateRequest> {
    constructor() {
        super("SettlementRecurringTransactionCreateRequest", [
            { no: 1, name: "driver_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "amount", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "start_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "category_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "category_type", kind: "enum", T: () => ["SettlementTransactionCategoryModel.Type", SettlementTransactionCategoryModel_Type, "TYPE_"] },
            { no: 6, name: "max_total_amount", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "note", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SettlementRecurringTransactionCreateRequest>): SettlementRecurringTransactionCreateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.driverId = "";
        message.amount = 0;
        message.startDate = "";
        message.categoryId = "";
        message.categoryType = 0;
        if (value !== undefined)
            reflectionMergePartial<SettlementRecurringTransactionCreateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SettlementRecurringTransactionCreateRequest): SettlementRecurringTransactionCreateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string driver_id */ 1:
                    message.driverId = reader.string();
                    break;
                case /* double amount */ 2:
                    message.amount = reader.double();
                    break;
                case /* string start_date */ 3:
                    message.startDate = reader.string();
                    break;
                case /* string category_id */ 4:
                    message.categoryId = reader.string();
                    break;
                case /* SettlementTransactionCategoryModel.Type category_type */ 5:
                    message.categoryType = reader.int32();
                    break;
                case /* optional double max_total_amount */ 6:
                    message.maxTotalAmount = reader.double();
                    break;
                case /* optional string note */ 7:
                    message.note = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SettlementRecurringTransactionCreateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string driver_id = 1; */
        if (message.driverId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.driverId);
        /* double amount = 2; */
        if (message.amount !== 0)
            writer.tag(2, WireType.Bit64).double(message.amount);
        /* string start_date = 3; */
        if (message.startDate !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.startDate);
        /* string category_id = 4; */
        if (message.categoryId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.categoryId);
        /* SettlementTransactionCategoryModel.Type category_type = 5; */
        if (message.categoryType !== 0)
            writer.tag(5, WireType.Varint).int32(message.categoryType);
        /* optional double max_total_amount = 6; */
        if (message.maxTotalAmount !== undefined)
            writer.tag(6, WireType.Bit64).double(message.maxTotalAmount);
        /* optional string note = 7; */
        if (message.note !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.note);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SettlementRecurringTransactionCreateRequest
 */
export const SettlementRecurringTransactionCreateRequest = new SettlementRecurringTransactionCreateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SettlementRecurringTransactionCreateReply$Type extends MessageType<SettlementRecurringTransactionCreateReply> {
    constructor() {
        super("SettlementRecurringTransactionCreateReply", [
            { no: 1, name: "recurring_transaction_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SettlementRecurringTransactionCreateReply>): SettlementRecurringTransactionCreateReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.recurringTransactionId = "";
        if (value !== undefined)
            reflectionMergePartial<SettlementRecurringTransactionCreateReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SettlementRecurringTransactionCreateReply): SettlementRecurringTransactionCreateReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string recurring_transaction_id */ 1:
                    message.recurringTransactionId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SettlementRecurringTransactionCreateReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string recurring_transaction_id = 1; */
        if (message.recurringTransactionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.recurringTransactionId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SettlementRecurringTransactionCreateReply
 */
export const SettlementRecurringTransactionCreateReply = new SettlementRecurringTransactionCreateReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SettlementRecurringTransactionDeleteRequest$Type extends MessageType<SettlementRecurringTransactionDeleteRequest> {
    constructor() {
        super("SettlementRecurringTransactionDeleteRequest", [
            { no: 1, name: "recurring_transaction_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SettlementRecurringTransactionDeleteRequest>): SettlementRecurringTransactionDeleteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.recurringTransactionId = "";
        if (value !== undefined)
            reflectionMergePartial<SettlementRecurringTransactionDeleteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SettlementRecurringTransactionDeleteRequest): SettlementRecurringTransactionDeleteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string recurring_transaction_id */ 1:
                    message.recurringTransactionId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SettlementRecurringTransactionDeleteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string recurring_transaction_id = 1; */
        if (message.recurringTransactionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.recurringTransactionId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SettlementRecurringTransactionDeleteRequest
 */
export const SettlementRecurringTransactionDeleteRequest = new SettlementRecurringTransactionDeleteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SettlementRecurringTransactionDeleteReply$Type extends MessageType<SettlementRecurringTransactionDeleteReply> {
    constructor() {
        super("SettlementRecurringTransactionDeleteReply", []);
    }
    create(value?: PartialMessage<SettlementRecurringTransactionDeleteReply>): SettlementRecurringTransactionDeleteReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SettlementRecurringTransactionDeleteReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SettlementRecurringTransactionDeleteReply): SettlementRecurringTransactionDeleteReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SettlementRecurringTransactionDeleteReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SettlementRecurringTransactionDeleteReply
 */
export const SettlementRecurringTransactionDeleteReply = new SettlementRecurringTransactionDeleteReply$Type();
/**
 * @generated ServiceType for protobuf service SettlementRecurringTransactionService
 */
export const SettlementRecurringTransactionService = new ServiceType("SettlementRecurringTransactionService", [
    { name: "SettlementRecurringTransactionGet", options: {}, I: SettlementRecurringTransactionGetRequest, O: SettlementRecurringTransactionGetReply },
    { name: "SettlementRecurringTransactionRetrieve", options: {}, I: SettlementRecurringTransactionRetrieveRequest, O: SettlementRecurringTransactionRetrieveReply },
    { name: "SettlementRecurringTransactionUpdate", options: {}, I: SettlementRecurringTransactionUpdateRequest, O: SettlementRecurringTransactionUpdateReply },
    { name: "SettlementRecurringTransactionStatusUpdate", options: {}, I: SettlementRecurringTransactionStatusUpdateRequest, O: SettlementRecurringTransactionStatusUpdateReply },
    { name: "SettlementRecurringTransactionCreate", options: {}, I: SettlementRecurringTransactionCreateRequest, O: SettlementRecurringTransactionCreateReply },
    { name: "SettlementRecurringTransactionDelete", options: {}, I: SettlementRecurringTransactionDeleteRequest, O: SettlementRecurringTransactionDeleteReply }
]);
