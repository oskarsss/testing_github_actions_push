// @generated by protobuf-ts 2.9.4 with parameter long_type_number,generate_dependencies,ts_nocheck,output_typescript
// @generated from protobuf file "v1/notes.proto" (syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { NoteModel_Note_File } from "./models/model_note";
import { NoteModel_Note } from "./models/model_note";
/**
 * Get Notes 1
 *
 * @generated from protobuf message GetNotesRequest
 */
export interface GetNotesRequest {
    /**
     * @generated from protobuf field: string entity_type = 1;
     */
    entityType: string;
    /**
     * @generated from protobuf field: string entity_id = 2;
     */
    entityId: string;
    /**
     * @generated from protobuf field: optional int64 per_page = 3;
     */
    perPage?: number;
    /**
     * @generated from protobuf field: optional int64 page = 4;
     */
    page?: number;
    /**
     * @generated from protobuf field: string device_id = 5;
     */
    deviceId: string;
}
/**
 * @generated from protobuf message GetNotesReply
 */
export interface GetNotesReply {
    /**
     * @generated from protobuf field: repeated NoteModel.Note notes = 1;
     */
    notes: NoteModel_Note[];
}
/**
 * Create Note
 *
 * @generated from protobuf message CreateNoteRequest
 */
export interface CreateNoteRequest {
    /**
     * @generated from protobuf field: string entity_id = 1;
     */
    entityId: string;
    /**
     * @generated from protobuf field: string entity_type = 2;
     */
    entityType: string;
    /**
     * @generated from protobuf field: string body = 3;
     */
    body: string;
    /**
     * @generated from protobuf field: repeated NoteModel.Note.File files = 4;
     */
    files: NoteModel_Note_File[];
}
/**
 * @generated from protobuf message CreateNoteReply
 */
export interface CreateNoteReply {
    /**
     * @generated from protobuf field: NoteModel.Note note = 1;
     */
    note?: NoteModel_Note;
}
/**
 * Update Note
 *
 * @generated from protobuf message UpdateNoteRequest
 */
export interface UpdateNoteRequest {
    /**
     * @generated from protobuf field: string note_id = 1;
     */
    noteId: string;
    /**
     * @generated from protobuf field: string body = 2;
     */
    body: string;
    /**
     * @generated from protobuf field: repeated NoteModel.Note.File files = 3;
     */
    files: NoteModel_Note_File[];
}
/**
 * @generated from protobuf message UpdateNoteReply
 */
export interface UpdateNoteReply {
    /**
     * @generated from protobuf field: NoteModel.Note note = 1;
     */
    note?: NoteModel_Note;
}
/**
 * Delete Note
 *
 * @generated from protobuf message DeleteNoteRequest
 */
export interface DeleteNoteRequest {
    /**
     * @generated from protobuf field: string note_id = 1;
     */
    noteId: string;
}
/**
 * @generated from protobuf message DeleteNoteReply
 */
export interface DeleteNoteReply {
    /**
     * @generated from protobuf field: NoteModel.Note note = 1;
     */
    note?: NoteModel_Note;
}
/**
 * Read Notes
 *
 * @generated from protobuf message ReadNotesRequest
 */
export interface ReadNotesRequest {
    /**
     * @generated from protobuf field: string entity_type = 1;
     */
    entityType: string;
    /**
     * @generated from protobuf field: string entity_id = 2;
     */
    entityId: string;
}
/**
 * @generated from protobuf message ReadNotesReply
 */
export interface ReadNotesReply {
}
// @generated message type with reflection information, may provide speed optimized methods
class GetNotesRequest$Type extends MessageType<GetNotesRequest> {
    constructor() {
        super("GetNotesRequest", [
            { no: 1, name: "entity_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "entity_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "per_page", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "page", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 5, name: "device_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetNotesRequest>): GetNotesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entityType = "";
        message.entityId = "";
        message.deviceId = "";
        if (value !== undefined)
            reflectionMergePartial<GetNotesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetNotesRequest): GetNotesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string entity_type */ 1:
                    message.entityType = reader.string();
                    break;
                case /* string entity_id */ 2:
                    message.entityId = reader.string();
                    break;
                case /* optional int64 per_page */ 3:
                    message.perPage = reader.int64().toNumber();
                    break;
                case /* optional int64 page */ 4:
                    message.page = reader.int64().toNumber();
                    break;
                case /* string device_id */ 5:
                    message.deviceId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetNotesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string entity_type = 1; */
        if (message.entityType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.entityType);
        /* string entity_id = 2; */
        if (message.entityId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.entityId);
        /* optional int64 per_page = 3; */
        if (message.perPage !== undefined)
            writer.tag(3, WireType.Varint).int64(message.perPage);
        /* optional int64 page = 4; */
        if (message.page !== undefined)
            writer.tag(4, WireType.Varint).int64(message.page);
        /* string device_id = 5; */
        if (message.deviceId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.deviceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetNotesRequest
 */
export const GetNotesRequest = new GetNotesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetNotesReply$Type extends MessageType<GetNotesReply> {
    constructor() {
        super("GetNotesReply", [
            { no: 1, name: "notes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NoteModel_Note }
        ]);
    }
    create(value?: PartialMessage<GetNotesReply>): GetNotesReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.notes = [];
        if (value !== undefined)
            reflectionMergePartial<GetNotesReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetNotesReply): GetNotesReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated NoteModel.Note notes */ 1:
                    message.notes.push(NoteModel_Note.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetNotesReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated NoteModel.Note notes = 1; */
        for (let i = 0; i < message.notes.length; i++)
            NoteModel_Note.internalBinaryWrite(message.notes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetNotesReply
 */
export const GetNotesReply = new GetNotesReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateNoteRequest$Type extends MessageType<CreateNoteRequest> {
    constructor() {
        super("CreateNoteRequest", [
            { no: 1, name: "entity_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "entity_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "body", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "files", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NoteModel_Note_File }
        ]);
    }
    create(value?: PartialMessage<CreateNoteRequest>): CreateNoteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entityId = "";
        message.entityType = "";
        message.body = "";
        message.files = [];
        if (value !== undefined)
            reflectionMergePartial<CreateNoteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateNoteRequest): CreateNoteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string entity_id */ 1:
                    message.entityId = reader.string();
                    break;
                case /* string entity_type */ 2:
                    message.entityType = reader.string();
                    break;
                case /* string body */ 3:
                    message.body = reader.string();
                    break;
                case /* repeated NoteModel.Note.File files */ 4:
                    message.files.push(NoteModel_Note_File.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateNoteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string entity_id = 1; */
        if (message.entityId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.entityId);
        /* string entity_type = 2; */
        if (message.entityType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.entityType);
        /* string body = 3; */
        if (message.body !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.body);
        /* repeated NoteModel.Note.File files = 4; */
        for (let i = 0; i < message.files.length; i++)
            NoteModel_Note_File.internalBinaryWrite(message.files[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CreateNoteRequest
 */
export const CreateNoteRequest = new CreateNoteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateNoteReply$Type extends MessageType<CreateNoteReply> {
    constructor() {
        super("CreateNoteReply", [
            { no: 1, name: "note", kind: "message", T: () => NoteModel_Note }
        ]);
    }
    create(value?: PartialMessage<CreateNoteReply>): CreateNoteReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateNoteReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateNoteReply): CreateNoteReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* NoteModel.Note note */ 1:
                    message.note = NoteModel_Note.internalBinaryRead(reader, reader.uint32(), options, message.note);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateNoteReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* NoteModel.Note note = 1; */
        if (message.note)
            NoteModel_Note.internalBinaryWrite(message.note, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CreateNoteReply
 */
export const CreateNoteReply = new CreateNoteReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateNoteRequest$Type extends MessageType<UpdateNoteRequest> {
    constructor() {
        super("UpdateNoteRequest", [
            { no: 1, name: "note_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "body", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "files", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NoteModel_Note_File }
        ]);
    }
    create(value?: PartialMessage<UpdateNoteRequest>): UpdateNoteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.noteId = "";
        message.body = "";
        message.files = [];
        if (value !== undefined)
            reflectionMergePartial<UpdateNoteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateNoteRequest): UpdateNoteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string note_id */ 1:
                    message.noteId = reader.string();
                    break;
                case /* string body */ 2:
                    message.body = reader.string();
                    break;
                case /* repeated NoteModel.Note.File files */ 3:
                    message.files.push(NoteModel_Note_File.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateNoteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string note_id = 1; */
        if (message.noteId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.noteId);
        /* string body = 2; */
        if (message.body !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.body);
        /* repeated NoteModel.Note.File files = 3; */
        for (let i = 0; i < message.files.length; i++)
            NoteModel_Note_File.internalBinaryWrite(message.files[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdateNoteRequest
 */
export const UpdateNoteRequest = new UpdateNoteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateNoteReply$Type extends MessageType<UpdateNoteReply> {
    constructor() {
        super("UpdateNoteReply", [
            { no: 1, name: "note", kind: "message", T: () => NoteModel_Note }
        ]);
    }
    create(value?: PartialMessage<UpdateNoteReply>): UpdateNoteReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateNoteReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateNoteReply): UpdateNoteReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* NoteModel.Note note */ 1:
                    message.note = NoteModel_Note.internalBinaryRead(reader, reader.uint32(), options, message.note);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateNoteReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* NoteModel.Note note = 1; */
        if (message.note)
            NoteModel_Note.internalBinaryWrite(message.note, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdateNoteReply
 */
export const UpdateNoteReply = new UpdateNoteReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteNoteRequest$Type extends MessageType<DeleteNoteRequest> {
    constructor() {
        super("DeleteNoteRequest", [
            { no: 1, name: "note_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteNoteRequest>): DeleteNoteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.noteId = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteNoteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteNoteRequest): DeleteNoteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string note_id */ 1:
                    message.noteId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteNoteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string note_id = 1; */
        if (message.noteId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.noteId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DeleteNoteRequest
 */
export const DeleteNoteRequest = new DeleteNoteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteNoteReply$Type extends MessageType<DeleteNoteReply> {
    constructor() {
        super("DeleteNoteReply", [
            { no: 1, name: "note", kind: "message", T: () => NoteModel_Note }
        ]);
    }
    create(value?: PartialMessage<DeleteNoteReply>): DeleteNoteReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteNoteReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteNoteReply): DeleteNoteReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* NoteModel.Note note */ 1:
                    message.note = NoteModel_Note.internalBinaryRead(reader, reader.uint32(), options, message.note);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteNoteReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* NoteModel.Note note = 1; */
        if (message.note)
            NoteModel_Note.internalBinaryWrite(message.note, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DeleteNoteReply
 */
export const DeleteNoteReply = new DeleteNoteReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadNotesRequest$Type extends MessageType<ReadNotesRequest> {
    constructor() {
        super("ReadNotesRequest", [
            { no: 1, name: "entity_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "entity_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ReadNotesRequest>): ReadNotesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entityType = "";
        message.entityId = "";
        if (value !== undefined)
            reflectionMergePartial<ReadNotesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadNotesRequest): ReadNotesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string entity_type */ 1:
                    message.entityType = reader.string();
                    break;
                case /* string entity_id */ 2:
                    message.entityId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadNotesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string entity_type = 1; */
        if (message.entityType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.entityType);
        /* string entity_id = 2; */
        if (message.entityId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.entityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ReadNotesRequest
 */
export const ReadNotesRequest = new ReadNotesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadNotesReply$Type extends MessageType<ReadNotesReply> {
    constructor() {
        super("ReadNotesReply", []);
    }
    create(value?: PartialMessage<ReadNotesReply>): ReadNotesReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ReadNotesReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadNotesReply): ReadNotesReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ReadNotesReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ReadNotesReply
 */
export const ReadNotesReply = new ReadNotesReply$Type();
/**
 * @generated ServiceType for protobuf service NotesService
 */
export const NotesService = new ServiceType("NotesService", [
    { name: "GetNotes", options: {}, I: GetNotesRequest, O: GetNotesReply },
    { name: "CreateNote", options: {}, I: CreateNoteRequest, O: CreateNoteReply },
    { name: "UpdateNote", options: {}, I: UpdateNoteRequest, O: UpdateNoteReply },
    { name: "DeleteNote", options: {}, I: DeleteNoteRequest, O: DeleteNoteReply },
    { name: "ReadNotes", options: {}, I: ReadNotesRequest, O: ReadNotesReply }
]);
