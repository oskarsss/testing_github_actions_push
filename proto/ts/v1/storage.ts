// @generated by protobuf-ts 2.9.4 with parameter long_type_number,generate_dependencies,ts_nocheck,output_typescript
// @generated from protobuf file "v1/storage.proto" (syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { FileModel_MimeType } from "./models/model_file";
/**
 * Storage File Delete
 *
 * @generated from protobuf message StorageFileDeleteRequest
 */
export interface StorageFileDeleteRequest {
    /**
     * @generated from protobuf field: string file_id = 1;
     */
    fileId: string;
}
/**
 * @generated from protobuf message StorageFileDeleteReply
 */
export interface StorageFileDeleteReply {
}
/**
 * Storage File Retrieve By ID
 *
 * @generated from protobuf message StorageFileRetrieveRequest
 */
export interface StorageFileRetrieveRequest {
    /**
     * @generated from protobuf field: string file_id = 1;
     */
    fileId: string;
}
/**
 * @generated from protobuf message StorageFileRetrieveReply
 */
export interface StorageFileRetrieveReply {
    /**
     * @generated from protobuf field: bytes chunk = 1;
     */
    chunk: Uint8Array;
    /**
     * @generated from protobuf field: optional string name = 2;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional FileModel.MimeType mime_type = 3;
     */
    mimeType?: FileModel_MimeType;
}
/**
 * Storage File Upload [Single]
 *
 * @generated from protobuf message StorageFileUploadRequest
 */
export interface StorageFileUploadRequest {
    /**
     * @generated from protobuf field: bytes data = 1;
     */
    data: Uint8Array;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: FileModel.MimeType mime_type = 3;
     */
    mimeType: FileModel_MimeType;
    /**
     * @generated from protobuf field: bool thumb_needed = 4;
     */
    thumbNeeded: boolean;
}
/**
 * @generated from protobuf message StorageFileUploadReply
 */
export interface StorageFileUploadReply {
    /**
     * @generated from protobuf field: string file_id = 1;
     */
    fileId: string;
    /**
     * @generated from protobuf field: optional string thumb_file_id = 2;
     */
    thumbFileId?: string;
}
/**
 * Storage Files Upload [Multiple]
 *
 * @generated from protobuf message StorageFilesUploadRequest
 */
export interface StorageFilesUploadRequest {
    /**
     * @generated from protobuf field: repeated StorageFilesUploadRequest.File files = 1;
     */
    files: StorageFilesUploadRequest_File[];
}
/**
 * @generated from protobuf message StorageFilesUploadRequest.File
 */
export interface StorageFilesUploadRequest_File {
    /**
     * @generated from protobuf field: bytes data = 1;
     */
    data: Uint8Array;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: FileModel.MimeType mime_type = 3;
     */
    mimeType: FileModel_MimeType;
}
/**
 * @generated from protobuf message StorageFilesUploadReply
 */
export interface StorageFilesUploadReply {
    /**
     * @generated from protobuf field: string file_id = 1;
     */
    fileId: string;
}
/**
 * Storage File Upload [Public]
 *
 * @generated from protobuf message StorageFileUploadPublicRequest
 */
export interface StorageFileUploadPublicRequest {
    /**
     * @generated from protobuf field: bytes data = 1;
     */
    data: Uint8Array;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: FileModel.MimeType mime_type = 3;
     */
    mimeType: FileModel_MimeType;
}
/**
 * @generated from protobuf message StorageFileUploadPublicReply
 */
export interface StorageFileUploadPublicReply {
    /**
     * @generated from protobuf field: string file_path = 1;
     */
    filePath: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class StorageFileDeleteRequest$Type extends MessageType<StorageFileDeleteRequest> {
    constructor() {
        super("StorageFileDeleteRequest", [
            { no: 1, name: "file_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StorageFileDeleteRequest>): StorageFileDeleteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fileId = "";
        if (value !== undefined)
            reflectionMergePartial<StorageFileDeleteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StorageFileDeleteRequest): StorageFileDeleteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string file_id */ 1:
                    message.fileId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StorageFileDeleteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string file_id = 1; */
        if (message.fileId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.fileId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StorageFileDeleteRequest
 */
export const StorageFileDeleteRequest = new StorageFileDeleteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StorageFileDeleteReply$Type extends MessageType<StorageFileDeleteReply> {
    constructor() {
        super("StorageFileDeleteReply", []);
    }
    create(value?: PartialMessage<StorageFileDeleteReply>): StorageFileDeleteReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StorageFileDeleteReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StorageFileDeleteReply): StorageFileDeleteReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: StorageFileDeleteReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StorageFileDeleteReply
 */
export const StorageFileDeleteReply = new StorageFileDeleteReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StorageFileRetrieveRequest$Type extends MessageType<StorageFileRetrieveRequest> {
    constructor() {
        super("StorageFileRetrieveRequest", [
            { no: 1, name: "file_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StorageFileRetrieveRequest>): StorageFileRetrieveRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fileId = "";
        if (value !== undefined)
            reflectionMergePartial<StorageFileRetrieveRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StorageFileRetrieveRequest): StorageFileRetrieveRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string file_id */ 1:
                    message.fileId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StorageFileRetrieveRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string file_id = 1; */
        if (message.fileId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.fileId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StorageFileRetrieveRequest
 */
export const StorageFileRetrieveRequest = new StorageFileRetrieveRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StorageFileRetrieveReply$Type extends MessageType<StorageFileRetrieveReply> {
    constructor() {
        super("StorageFileRetrieveReply", [
            { no: 1, name: "chunk", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "mime_type", kind: "enum", opt: true, T: () => ["FileModel.MimeType", FileModel_MimeType, "MIME_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<StorageFileRetrieveReply>): StorageFileRetrieveReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.chunk = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<StorageFileRetrieveReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StorageFileRetrieveReply): StorageFileRetrieveReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes chunk */ 1:
                    message.chunk = reader.bytes();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                case /* optional FileModel.MimeType mime_type */ 3:
                    message.mimeType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StorageFileRetrieveReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes chunk = 1; */
        if (message.chunk.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.chunk);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* optional FileModel.MimeType mime_type = 3; */
        if (message.mimeType !== undefined)
            writer.tag(3, WireType.Varint).int32(message.mimeType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StorageFileRetrieveReply
 */
export const StorageFileRetrieveReply = new StorageFileRetrieveReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StorageFileUploadRequest$Type extends MessageType<StorageFileUploadRequest> {
    constructor() {
        super("StorageFileUploadRequest", [
            { no: 1, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "mime_type", kind: "enum", T: () => ["FileModel.MimeType", FileModel_MimeType, "MIME_TYPE_"] },
            { no: 4, name: "thumb_needed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<StorageFileUploadRequest>): StorageFileUploadRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = new Uint8Array(0);
        message.name = "";
        message.mimeType = 0;
        message.thumbNeeded = false;
        if (value !== undefined)
            reflectionMergePartial<StorageFileUploadRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StorageFileUploadRequest): StorageFileUploadRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes data */ 1:
                    message.data = reader.bytes();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* FileModel.MimeType mime_type */ 3:
                    message.mimeType = reader.int32();
                    break;
                case /* bool thumb_needed */ 4:
                    message.thumbNeeded = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StorageFileUploadRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes data = 1; */
        if (message.data.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.data);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* FileModel.MimeType mime_type = 3; */
        if (message.mimeType !== 0)
            writer.tag(3, WireType.Varint).int32(message.mimeType);
        /* bool thumb_needed = 4; */
        if (message.thumbNeeded !== false)
            writer.tag(4, WireType.Varint).bool(message.thumbNeeded);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StorageFileUploadRequest
 */
export const StorageFileUploadRequest = new StorageFileUploadRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StorageFileUploadReply$Type extends MessageType<StorageFileUploadReply> {
    constructor() {
        super("StorageFileUploadReply", [
            { no: 1, name: "file_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "thumb_file_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StorageFileUploadReply>): StorageFileUploadReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fileId = "";
        if (value !== undefined)
            reflectionMergePartial<StorageFileUploadReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StorageFileUploadReply): StorageFileUploadReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string file_id */ 1:
                    message.fileId = reader.string();
                    break;
                case /* optional string thumb_file_id */ 2:
                    message.thumbFileId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StorageFileUploadReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string file_id = 1; */
        if (message.fileId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.fileId);
        /* optional string thumb_file_id = 2; */
        if (message.thumbFileId !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.thumbFileId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StorageFileUploadReply
 */
export const StorageFileUploadReply = new StorageFileUploadReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StorageFilesUploadRequest$Type extends MessageType<StorageFilesUploadRequest> {
    constructor() {
        super("StorageFilesUploadRequest", [
            { no: 1, name: "files", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => StorageFilesUploadRequest_File }
        ]);
    }
    create(value?: PartialMessage<StorageFilesUploadRequest>): StorageFilesUploadRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.files = [];
        if (value !== undefined)
            reflectionMergePartial<StorageFilesUploadRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StorageFilesUploadRequest): StorageFilesUploadRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated StorageFilesUploadRequest.File files */ 1:
                    message.files.push(StorageFilesUploadRequest_File.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StorageFilesUploadRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated StorageFilesUploadRequest.File files = 1; */
        for (let i = 0; i < message.files.length; i++)
            StorageFilesUploadRequest_File.internalBinaryWrite(message.files[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StorageFilesUploadRequest
 */
export const StorageFilesUploadRequest = new StorageFilesUploadRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StorageFilesUploadRequest_File$Type extends MessageType<StorageFilesUploadRequest_File> {
    constructor() {
        super("StorageFilesUploadRequest.File", [
            { no: 1, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "mime_type", kind: "enum", T: () => ["FileModel.MimeType", FileModel_MimeType, "MIME_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<StorageFilesUploadRequest_File>): StorageFilesUploadRequest_File {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = new Uint8Array(0);
        message.name = "";
        message.mimeType = 0;
        if (value !== undefined)
            reflectionMergePartial<StorageFilesUploadRequest_File>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StorageFilesUploadRequest_File): StorageFilesUploadRequest_File {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes data */ 1:
                    message.data = reader.bytes();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* FileModel.MimeType mime_type */ 3:
                    message.mimeType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StorageFilesUploadRequest_File, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes data = 1; */
        if (message.data.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.data);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* FileModel.MimeType mime_type = 3; */
        if (message.mimeType !== 0)
            writer.tag(3, WireType.Varint).int32(message.mimeType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StorageFilesUploadRequest.File
 */
export const StorageFilesUploadRequest_File = new StorageFilesUploadRequest_File$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StorageFilesUploadReply$Type extends MessageType<StorageFilesUploadReply> {
    constructor() {
        super("StorageFilesUploadReply", [
            { no: 1, name: "file_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StorageFilesUploadReply>): StorageFilesUploadReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fileId = "";
        if (value !== undefined)
            reflectionMergePartial<StorageFilesUploadReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StorageFilesUploadReply): StorageFilesUploadReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string file_id */ 1:
                    message.fileId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StorageFilesUploadReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string file_id = 1; */
        if (message.fileId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.fileId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StorageFilesUploadReply
 */
export const StorageFilesUploadReply = new StorageFilesUploadReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StorageFileUploadPublicRequest$Type extends MessageType<StorageFileUploadPublicRequest> {
    constructor() {
        super("StorageFileUploadPublicRequest", [
            { no: 1, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "mime_type", kind: "enum", T: () => ["FileModel.MimeType", FileModel_MimeType, "MIME_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<StorageFileUploadPublicRequest>): StorageFileUploadPublicRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = new Uint8Array(0);
        message.name = "";
        message.mimeType = 0;
        if (value !== undefined)
            reflectionMergePartial<StorageFileUploadPublicRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StorageFileUploadPublicRequest): StorageFileUploadPublicRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes data */ 1:
                    message.data = reader.bytes();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* FileModel.MimeType mime_type */ 3:
                    message.mimeType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StorageFileUploadPublicRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes data = 1; */
        if (message.data.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.data);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* FileModel.MimeType mime_type = 3; */
        if (message.mimeType !== 0)
            writer.tag(3, WireType.Varint).int32(message.mimeType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StorageFileUploadPublicRequest
 */
export const StorageFileUploadPublicRequest = new StorageFileUploadPublicRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StorageFileUploadPublicReply$Type extends MessageType<StorageFileUploadPublicReply> {
    constructor() {
        super("StorageFileUploadPublicReply", [
            { no: 1, name: "file_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StorageFileUploadPublicReply>): StorageFileUploadPublicReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.filePath = "";
        if (value !== undefined)
            reflectionMergePartial<StorageFileUploadPublicReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StorageFileUploadPublicReply): StorageFileUploadPublicReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string file_path */ 1:
                    message.filePath = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StorageFileUploadPublicReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string file_path = 1; */
        if (message.filePath !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.filePath);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StorageFileUploadPublicReply
 */
export const StorageFileUploadPublicReply = new StorageFileUploadPublicReply$Type();
/**
 * @generated ServiceType for protobuf service StorageService
 */
export const StorageService = new ServiceType("StorageService", [
    { name: "StorageFileDelete", options: {}, I: StorageFileDeleteRequest, O: StorageFileDeleteReply },
    { name: "StorageFileRetrieve", serverStreaming: true, options: {}, I: StorageFileRetrieveRequest, O: StorageFileRetrieveReply },
    { name: "StorageFileUpload", options: {}, I: StorageFileUploadRequest, O: StorageFileUploadReply },
    { name: "StorageFilesUpload", options: {}, I: StorageFilesUploadRequest, O: StorageFilesUploadReply },
    { name: "StorageFileUploadPublic", options: {}, I: StorageFileUploadPublicRequest, O: StorageFileUploadPublicReply }
]);
