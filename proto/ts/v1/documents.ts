// @generated by protobuf-ts 2.9.4 with parameter long_type_number,generate_dependencies,ts_nocheck,output_typescript
// @generated from protobuf file "v1/documents.proto" (syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { DocumentModel_Version } from "./models/model_document";
import { DocumentModel_Document } from "./models/model_document";
import { DocumentModel_Status } from "./models/model_document";
import { DocumentModel_DocumentEntityType } from "./models/model_document";
/**
 * DocumentCreate
 *
 * @generated from protobuf message DocumentCreateRequest
 */
export interface DocumentCreateRequest {
    /**
     * @generated from protobuf field: DocumentModel.DocumentEntityType entity_type = 1;
     */
    entityType: DocumentModel_DocumentEntityType;
    /**
     * @generated from protobuf field: string entity_id = 2;
     */
    entityId: string;
    /**
     * @generated from protobuf field: string document_type_id = 3;
     */
    documentTypeId: string;
}
/**
 * @generated from protobuf message DocumentCreateReply
 */
export interface DocumentCreateReply {
}
/**
 * DocumentUpdate
 *
 * @generated from protobuf message DocumentUpdateRequest
 */
export interface DocumentUpdateRequest {
    /**
     * @generated from protobuf field: DocumentModel.DocumentEntityType entity_type = 1;
     */
    entityType: DocumentModel_DocumentEntityType;
    /**
     * @generated from protobuf field: string entity_id = 2;
     */
    entityId: string;
    /**
     * @generated from protobuf field: string document_type_id = 3;
     */
    documentTypeId: string;
    /**
     *
     *
     * @generated from protobuf field: string state = 4;
     */
    state: string;
    /**
     * @generated from protobuf field: string number = 5;
     */
    number: string;
    /**
     * @generated from protobuf field: DocumentModel.Status status = 6;
     */
    status: DocumentModel_Status;
    /**
     * @generated from protobuf field: string expires_at = 7;
     */
    expiresAt: string;
}
/**
 * @generated from protobuf message DocumentUpdateReply
 */
export interface DocumentUpdateReply {
}
/**
 * DocumentsGet
 *
 * @generated from protobuf message DocumentGetRequest
 */
export interface DocumentGetRequest {
    /**
     * @generated from protobuf field: DocumentModel.DocumentEntityType entity_type = 1;
     */
    entityType: DocumentModel_DocumentEntityType;
    /**
     * @generated from protobuf field: string entity_id = 2;
     */
    entityId: string;
}
/**
 * @generated from protobuf message DocumentGetReply
 */
export interface DocumentGetReply {
    /**
     * @generated from protobuf field: repeated DocumentModel.Document documents = 1;
     */
    documents: DocumentModel_Document[];
}
/**
 * DocumentDelete
 *
 * @generated from protobuf message DocumentDeleteRequest
 */
export interface DocumentDeleteRequest {
    /**
     * @generated from protobuf field: DocumentModel.DocumentEntityType entity_type = 1;
     */
    entityType: DocumentModel_DocumentEntityType;
    /**
     * @generated from protobuf field: string entity_id = 2;
     */
    entityId: string;
    /**
     * @generated from protobuf field: string document_type_id = 3;
     */
    documentTypeId: string;
}
/**
 * @generated from protobuf message DocumentDeleteReply
 */
export interface DocumentDeleteReply {
}
/**
 * DocumentFileClear
 *
 * @generated from protobuf message DocumentFileClearRequest
 */
export interface DocumentFileClearRequest {
    /**
     * @generated from protobuf field: DocumentModel.DocumentEntityType entity_type = 1;
     */
    entityType: DocumentModel_DocumentEntityType;
    /**
     * @generated from protobuf field: string entity_id = 2;
     */
    entityId: string;
    /**
     * @generated from protobuf field: string document_type_id = 3;
     */
    documentTypeId: string;
}
/**
 * @generated from protobuf message DocumentFileClearReply
 */
export interface DocumentFileClearReply {
}
/**
 * DocumentFileUpdate
 *
 * @generated from protobuf message DocumentFileUpdateRequest
 */
export interface DocumentFileUpdateRequest {
    /**
     * @generated from protobuf field: DocumentModel.DocumentEntityType entity_type = 1;
     */
    entityType: DocumentModel_DocumentEntityType;
    /**
     * @generated from protobuf field: string entity_id = 2;
     */
    entityId: string;
    /**
     * @generated from protobuf field: string document_type_id = 3;
     */
    documentTypeId: string;
    /**
     * @generated from protobuf field: string file_id = 4;
     */
    fileId: string;
}
/**
 * @generated from protobuf message DocumentFileUpdateReply
 */
export interface DocumentFileUpdateReply {
}
/**
 * DocumentGetVersions
 *
 * @generated from protobuf message DocumentGetVersionsRequest
 */
export interface DocumentGetVersionsRequest {
    /**
     * @generated from protobuf field: DocumentModel.DocumentEntityType entity_type = 1;
     */
    entityType: DocumentModel_DocumentEntityType;
    /**
     * @generated from protobuf field: string entity_id = 2;
     */
    entityId: string;
    /**
     * @generated from protobuf field: string document_type_id = 3;
     */
    documentTypeId: string;
}
/**
 * @generated from protobuf message DocumentGetVersionsReply
 */
export interface DocumentGetVersionsReply {
    /**
     * @generated from protobuf field: repeated DocumentModel.Version document_versions = 1;
     */
    documentVersions: DocumentModel_Version[];
}
/**
 * DocumentEntitiesGet
 *
 * @generated from protobuf message DocumentEntitiesGetRequest
 */
export interface DocumentEntitiesGetRequest {
    /**
     * @generated from protobuf field: repeated DocumentEntitiesGetRequest.Entity entities = 1;
     */
    entities: DocumentEntitiesGetRequest_Entity[];
}
/**
 * @generated from protobuf message DocumentEntitiesGetRequest.Entity
 */
export interface DocumentEntitiesGetRequest_Entity {
    /**
     * @generated from protobuf field: repeated string entity_ids = 1;
     */
    entityIds: string[];
    /**
     * @generated from protobuf field: DocumentModel.DocumentEntityType entity_type = 2;
     */
    entityType: DocumentModel_DocumentEntityType;
}
/**
 * @generated from protobuf message DocumentEntitiesGetReply
 */
export interface DocumentEntitiesGetReply {
    /**
     * @generated from protobuf field: repeated DocumentEntitiesGetReply.DocumentEntities document_entities = 1;
     */
    documentEntities: DocumentEntitiesGetReply_DocumentEntities[];
}
/**
 * @generated from protobuf message DocumentEntitiesGetReply.DocumentEntities
 */
export interface DocumentEntitiesGetReply_DocumentEntities {
    /**
     * @generated from protobuf field: DocumentModel.DocumentEntityType entity_type = 1;
     */
    entityType: DocumentModel_DocumentEntityType;
    /**
     * @generated from protobuf field: DocumentEntitiesGetReply.DocumentEntities.TypesByEntityID entity_documents = 2;
     */
    entityDocuments?: DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID;
}
/**
 * @generated from protobuf message DocumentEntitiesGetReply.DocumentEntities.TypesByEntityID
 */
export interface DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID {
    /**
     * @generated from protobuf field: map<string, DocumentEntitiesGetReply.DocumentEntities.TypesByEntityID.DocumentsByType> by_entity_id = 1;
     */
    byEntityId: {
        [key: string]: DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID_DocumentsByType;
    };
}
/**
 * @generated from protobuf message DocumentEntitiesGetReply.DocumentEntities.TypesByEntityID.DocumentsByType
 */
export interface DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID_DocumentsByType {
    /**
     * @generated from protobuf field: map<string, DocumentModel.Document> documents = 1;
     */
    documents: {
        [key: string]: DocumentModel_Document;
    };
}
/**
 * DocumentDownload
 *
 * @generated from protobuf message DocumentDownloadRequest
 */
export interface DocumentDownloadRequest {
    /**
     * @generated from protobuf field: repeated string document_type_ids = 1;
     */
    documentTypeIds: string[];
    /**
     * @generated from protobuf field: string entity_id = 2;
     */
    entityId: string;
    /**
     * @generated from protobuf field: DocumentModel.DocumentEntityType entity_type = 3;
     */
    entityType: DocumentModel_DocumentEntityType;
    /**
     * @generated from protobuf field: bool only_last_versions = 4;
     */
    onlyLastVersions: boolean; // if false, download all versions
}
/**
 * @generated from protobuf message DocumentDownloadReply
 */
export interface DocumentDownloadReply {
    /**
     * @generated from protobuf field: string file_id = 1;
     */
    fileId: string;
}
/**
 * DocumentsGetByEntity
 *
 * @generated from protobuf message DocumentImageRotateRequest
 */
export interface DocumentImageRotateRequest {
    /**
     * @generated from protobuf field: DocumentModel.DocumentEntityType entity_type = 1;
     */
    entityType: DocumentModel_DocumentEntityType;
    /**
     * @generated from protobuf field: string entity_id = 2;
     */
    entityId: string;
    /**
     * @generated from protobuf field: string document_type_id = 3;
     */
    documentTypeId: string;
    /**
     * @generated from protobuf field: int32 degree = 4;
     */
    degree: number;
    /**
     * @generated from protobuf field: int64 version_number = 5;
     */
    versionNumber: number;
}
/**
 * @generated from protobuf message DocumentImageRotateReply
 */
export interface DocumentImageRotateReply {
    /**
     * @generated from protobuf field: string file_id = 1;
     */
    fileId: string;
}
/**
 * DocumentVersionDelete
 *
 * @generated from protobuf message DocumentVersionDeleteRequest
 */
export interface DocumentVersionDeleteRequest {
    /**
     * @generated from protobuf field: DocumentModel.DocumentEntityType entity_type = 1;
     */
    entityType: DocumentModel_DocumentEntityType;
    /**
     * @generated from protobuf field: string entity_id = 2;
     */
    entityId: string;
    /**
     * @generated from protobuf field: string document_type_id = 3;
     */
    documentTypeId: string;
    /**
     * @generated from protobuf field: int64 version_number = 4;
     */
    versionNumber: number;
}
/**
 * @generated from protobuf message DocumentVersionDeleteReply
 */
export interface DocumentVersionDeleteReply {
}
// @generated message type with reflection information, may provide speed optimized methods
class DocumentCreateRequest$Type extends MessageType<DocumentCreateRequest> {
    constructor() {
        super("DocumentCreateRequest", [
            { no: 1, name: "entity_type", kind: "enum", T: () => ["DocumentModel.DocumentEntityType", DocumentModel_DocumentEntityType, "DOCUMENT_ENTITY_TYPE_"] },
            { no: 2, name: "entity_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "document_type_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentCreateRequest>): DocumentCreateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entityType = 0;
        message.entityId = "";
        message.documentTypeId = "";
        if (value !== undefined)
            reflectionMergePartial<DocumentCreateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentCreateRequest): DocumentCreateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* DocumentModel.DocumentEntityType entity_type */ 1:
                    message.entityType = reader.int32();
                    break;
                case /* string entity_id */ 2:
                    message.entityId = reader.string();
                    break;
                case /* string document_type_id */ 3:
                    message.documentTypeId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentCreateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* DocumentModel.DocumentEntityType entity_type = 1; */
        if (message.entityType !== 0)
            writer.tag(1, WireType.Varint).int32(message.entityType);
        /* string entity_id = 2; */
        if (message.entityId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.entityId);
        /* string document_type_id = 3; */
        if (message.documentTypeId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.documentTypeId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentCreateRequest
 */
export const DocumentCreateRequest = new DocumentCreateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentCreateReply$Type extends MessageType<DocumentCreateReply> {
    constructor() {
        super("DocumentCreateReply", []);
    }
    create(value?: PartialMessage<DocumentCreateReply>): DocumentCreateReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DocumentCreateReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentCreateReply): DocumentCreateReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DocumentCreateReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentCreateReply
 */
export const DocumentCreateReply = new DocumentCreateReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentUpdateRequest$Type extends MessageType<DocumentUpdateRequest> {
    constructor() {
        super("DocumentUpdateRequest", [
            { no: 1, name: "entity_type", kind: "enum", T: () => ["DocumentModel.DocumentEntityType", DocumentModel_DocumentEntityType, "DOCUMENT_ENTITY_TYPE_"] },
            { no: 2, name: "entity_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "document_type_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "number", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "status", kind: "enum", T: () => ["DocumentModel.Status", DocumentModel_Status] },
            { no: 7, name: "expires_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentUpdateRequest>): DocumentUpdateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entityType = 0;
        message.entityId = "";
        message.documentTypeId = "";
        message.state = "";
        message.number = "";
        message.status = 0;
        message.expiresAt = "";
        if (value !== undefined)
            reflectionMergePartial<DocumentUpdateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentUpdateRequest): DocumentUpdateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* DocumentModel.DocumentEntityType entity_type */ 1:
                    message.entityType = reader.int32();
                    break;
                case /* string entity_id */ 2:
                    message.entityId = reader.string();
                    break;
                case /* string document_type_id */ 3:
                    message.documentTypeId = reader.string();
                    break;
                case /* string state */ 4:
                    message.state = reader.string();
                    break;
                case /* string number */ 5:
                    message.number = reader.string();
                    break;
                case /* DocumentModel.Status status */ 6:
                    message.status = reader.int32();
                    break;
                case /* string expires_at */ 7:
                    message.expiresAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentUpdateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* DocumentModel.DocumentEntityType entity_type = 1; */
        if (message.entityType !== 0)
            writer.tag(1, WireType.Varint).int32(message.entityType);
        /* string entity_id = 2; */
        if (message.entityId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.entityId);
        /* string document_type_id = 3; */
        if (message.documentTypeId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.documentTypeId);
        /* string state = 4; */
        if (message.state !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.state);
        /* string number = 5; */
        if (message.number !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.number);
        /* DocumentModel.Status status = 6; */
        if (message.status !== 0)
            writer.tag(6, WireType.Varint).int32(message.status);
        /* string expires_at = 7; */
        if (message.expiresAt !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.expiresAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentUpdateRequest
 */
export const DocumentUpdateRequest = new DocumentUpdateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentUpdateReply$Type extends MessageType<DocumentUpdateReply> {
    constructor() {
        super("DocumentUpdateReply", []);
    }
    create(value?: PartialMessage<DocumentUpdateReply>): DocumentUpdateReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DocumentUpdateReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentUpdateReply): DocumentUpdateReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DocumentUpdateReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentUpdateReply
 */
export const DocumentUpdateReply = new DocumentUpdateReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentGetRequest$Type extends MessageType<DocumentGetRequest> {
    constructor() {
        super("DocumentGetRequest", [
            { no: 1, name: "entity_type", kind: "enum", T: () => ["DocumentModel.DocumentEntityType", DocumentModel_DocumentEntityType, "DOCUMENT_ENTITY_TYPE_"] },
            { no: 2, name: "entity_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentGetRequest>): DocumentGetRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entityType = 0;
        message.entityId = "";
        if (value !== undefined)
            reflectionMergePartial<DocumentGetRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentGetRequest): DocumentGetRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* DocumentModel.DocumentEntityType entity_type */ 1:
                    message.entityType = reader.int32();
                    break;
                case /* string entity_id */ 2:
                    message.entityId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentGetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* DocumentModel.DocumentEntityType entity_type = 1; */
        if (message.entityType !== 0)
            writer.tag(1, WireType.Varint).int32(message.entityType);
        /* string entity_id = 2; */
        if (message.entityId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.entityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentGetRequest
 */
export const DocumentGetRequest = new DocumentGetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentGetReply$Type extends MessageType<DocumentGetReply> {
    constructor() {
        super("DocumentGetReply", [
            { no: 1, name: "documents", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DocumentModel_Document }
        ]);
    }
    create(value?: PartialMessage<DocumentGetReply>): DocumentGetReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.documents = [];
        if (value !== undefined)
            reflectionMergePartial<DocumentGetReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentGetReply): DocumentGetReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated DocumentModel.Document documents */ 1:
                    message.documents.push(DocumentModel_Document.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentGetReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated DocumentModel.Document documents = 1; */
        for (let i = 0; i < message.documents.length; i++)
            DocumentModel_Document.internalBinaryWrite(message.documents[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentGetReply
 */
export const DocumentGetReply = new DocumentGetReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentDeleteRequest$Type extends MessageType<DocumentDeleteRequest> {
    constructor() {
        super("DocumentDeleteRequest", [
            { no: 1, name: "entity_type", kind: "enum", T: () => ["DocumentModel.DocumentEntityType", DocumentModel_DocumentEntityType, "DOCUMENT_ENTITY_TYPE_"] },
            { no: 2, name: "entity_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "document_type_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentDeleteRequest>): DocumentDeleteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entityType = 0;
        message.entityId = "";
        message.documentTypeId = "";
        if (value !== undefined)
            reflectionMergePartial<DocumentDeleteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentDeleteRequest): DocumentDeleteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* DocumentModel.DocumentEntityType entity_type */ 1:
                    message.entityType = reader.int32();
                    break;
                case /* string entity_id */ 2:
                    message.entityId = reader.string();
                    break;
                case /* string document_type_id */ 3:
                    message.documentTypeId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentDeleteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* DocumentModel.DocumentEntityType entity_type = 1; */
        if (message.entityType !== 0)
            writer.tag(1, WireType.Varint).int32(message.entityType);
        /* string entity_id = 2; */
        if (message.entityId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.entityId);
        /* string document_type_id = 3; */
        if (message.documentTypeId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.documentTypeId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentDeleteRequest
 */
export const DocumentDeleteRequest = new DocumentDeleteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentDeleteReply$Type extends MessageType<DocumentDeleteReply> {
    constructor() {
        super("DocumentDeleteReply", []);
    }
    create(value?: PartialMessage<DocumentDeleteReply>): DocumentDeleteReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DocumentDeleteReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentDeleteReply): DocumentDeleteReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DocumentDeleteReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentDeleteReply
 */
export const DocumentDeleteReply = new DocumentDeleteReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentFileClearRequest$Type extends MessageType<DocumentFileClearRequest> {
    constructor() {
        super("DocumentFileClearRequest", [
            { no: 1, name: "entity_type", kind: "enum", T: () => ["DocumentModel.DocumentEntityType", DocumentModel_DocumentEntityType, "DOCUMENT_ENTITY_TYPE_"] },
            { no: 2, name: "entity_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "document_type_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentFileClearRequest>): DocumentFileClearRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entityType = 0;
        message.entityId = "";
        message.documentTypeId = "";
        if (value !== undefined)
            reflectionMergePartial<DocumentFileClearRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentFileClearRequest): DocumentFileClearRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* DocumentModel.DocumentEntityType entity_type */ 1:
                    message.entityType = reader.int32();
                    break;
                case /* string entity_id */ 2:
                    message.entityId = reader.string();
                    break;
                case /* string document_type_id */ 3:
                    message.documentTypeId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentFileClearRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* DocumentModel.DocumentEntityType entity_type = 1; */
        if (message.entityType !== 0)
            writer.tag(1, WireType.Varint).int32(message.entityType);
        /* string entity_id = 2; */
        if (message.entityId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.entityId);
        /* string document_type_id = 3; */
        if (message.documentTypeId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.documentTypeId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentFileClearRequest
 */
export const DocumentFileClearRequest = new DocumentFileClearRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentFileClearReply$Type extends MessageType<DocumentFileClearReply> {
    constructor() {
        super("DocumentFileClearReply", []);
    }
    create(value?: PartialMessage<DocumentFileClearReply>): DocumentFileClearReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DocumentFileClearReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentFileClearReply): DocumentFileClearReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DocumentFileClearReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentFileClearReply
 */
export const DocumentFileClearReply = new DocumentFileClearReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentFileUpdateRequest$Type extends MessageType<DocumentFileUpdateRequest> {
    constructor() {
        super("DocumentFileUpdateRequest", [
            { no: 1, name: "entity_type", kind: "enum", T: () => ["DocumentModel.DocumentEntityType", DocumentModel_DocumentEntityType, "DOCUMENT_ENTITY_TYPE_"] },
            { no: 2, name: "entity_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "document_type_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "file_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentFileUpdateRequest>): DocumentFileUpdateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entityType = 0;
        message.entityId = "";
        message.documentTypeId = "";
        message.fileId = "";
        if (value !== undefined)
            reflectionMergePartial<DocumentFileUpdateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentFileUpdateRequest): DocumentFileUpdateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* DocumentModel.DocumentEntityType entity_type */ 1:
                    message.entityType = reader.int32();
                    break;
                case /* string entity_id */ 2:
                    message.entityId = reader.string();
                    break;
                case /* string document_type_id */ 3:
                    message.documentTypeId = reader.string();
                    break;
                case /* string file_id */ 4:
                    message.fileId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentFileUpdateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* DocumentModel.DocumentEntityType entity_type = 1; */
        if (message.entityType !== 0)
            writer.tag(1, WireType.Varint).int32(message.entityType);
        /* string entity_id = 2; */
        if (message.entityId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.entityId);
        /* string document_type_id = 3; */
        if (message.documentTypeId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.documentTypeId);
        /* string file_id = 4; */
        if (message.fileId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.fileId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentFileUpdateRequest
 */
export const DocumentFileUpdateRequest = new DocumentFileUpdateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentFileUpdateReply$Type extends MessageType<DocumentFileUpdateReply> {
    constructor() {
        super("DocumentFileUpdateReply", []);
    }
    create(value?: PartialMessage<DocumentFileUpdateReply>): DocumentFileUpdateReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DocumentFileUpdateReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentFileUpdateReply): DocumentFileUpdateReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DocumentFileUpdateReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentFileUpdateReply
 */
export const DocumentFileUpdateReply = new DocumentFileUpdateReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentGetVersionsRequest$Type extends MessageType<DocumentGetVersionsRequest> {
    constructor() {
        super("DocumentGetVersionsRequest", [
            { no: 1, name: "entity_type", kind: "enum", T: () => ["DocumentModel.DocumentEntityType", DocumentModel_DocumentEntityType, "DOCUMENT_ENTITY_TYPE_"] },
            { no: 2, name: "entity_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "document_type_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentGetVersionsRequest>): DocumentGetVersionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entityType = 0;
        message.entityId = "";
        message.documentTypeId = "";
        if (value !== undefined)
            reflectionMergePartial<DocumentGetVersionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentGetVersionsRequest): DocumentGetVersionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* DocumentModel.DocumentEntityType entity_type */ 1:
                    message.entityType = reader.int32();
                    break;
                case /* string entity_id */ 2:
                    message.entityId = reader.string();
                    break;
                case /* string document_type_id */ 3:
                    message.documentTypeId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentGetVersionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* DocumentModel.DocumentEntityType entity_type = 1; */
        if (message.entityType !== 0)
            writer.tag(1, WireType.Varint).int32(message.entityType);
        /* string entity_id = 2; */
        if (message.entityId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.entityId);
        /* string document_type_id = 3; */
        if (message.documentTypeId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.documentTypeId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentGetVersionsRequest
 */
export const DocumentGetVersionsRequest = new DocumentGetVersionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentGetVersionsReply$Type extends MessageType<DocumentGetVersionsReply> {
    constructor() {
        super("DocumentGetVersionsReply", [
            { no: 1, name: "document_versions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DocumentModel_Version }
        ]);
    }
    create(value?: PartialMessage<DocumentGetVersionsReply>): DocumentGetVersionsReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.documentVersions = [];
        if (value !== undefined)
            reflectionMergePartial<DocumentGetVersionsReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentGetVersionsReply): DocumentGetVersionsReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated DocumentModel.Version document_versions */ 1:
                    message.documentVersions.push(DocumentModel_Version.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentGetVersionsReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated DocumentModel.Version document_versions = 1; */
        for (let i = 0; i < message.documentVersions.length; i++)
            DocumentModel_Version.internalBinaryWrite(message.documentVersions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentGetVersionsReply
 */
export const DocumentGetVersionsReply = new DocumentGetVersionsReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentEntitiesGetRequest$Type extends MessageType<DocumentEntitiesGetRequest> {
    constructor() {
        super("DocumentEntitiesGetRequest", [
            { no: 1, name: "entities", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DocumentEntitiesGetRequest_Entity }
        ]);
    }
    create(value?: PartialMessage<DocumentEntitiesGetRequest>): DocumentEntitiesGetRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entities = [];
        if (value !== undefined)
            reflectionMergePartial<DocumentEntitiesGetRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentEntitiesGetRequest): DocumentEntitiesGetRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated DocumentEntitiesGetRequest.Entity entities */ 1:
                    message.entities.push(DocumentEntitiesGetRequest_Entity.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentEntitiesGetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated DocumentEntitiesGetRequest.Entity entities = 1; */
        for (let i = 0; i < message.entities.length; i++)
            DocumentEntitiesGetRequest_Entity.internalBinaryWrite(message.entities[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentEntitiesGetRequest
 */
export const DocumentEntitiesGetRequest = new DocumentEntitiesGetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentEntitiesGetRequest_Entity$Type extends MessageType<DocumentEntitiesGetRequest_Entity> {
    constructor() {
        super("DocumentEntitiesGetRequest.Entity", [
            { no: 1, name: "entity_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "entity_type", kind: "enum", T: () => ["DocumentModel.DocumentEntityType", DocumentModel_DocumentEntityType, "DOCUMENT_ENTITY_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<DocumentEntitiesGetRequest_Entity>): DocumentEntitiesGetRequest_Entity {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entityIds = [];
        message.entityType = 0;
        if (value !== undefined)
            reflectionMergePartial<DocumentEntitiesGetRequest_Entity>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentEntitiesGetRequest_Entity): DocumentEntitiesGetRequest_Entity {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string entity_ids */ 1:
                    message.entityIds.push(reader.string());
                    break;
                case /* DocumentModel.DocumentEntityType entity_type */ 2:
                    message.entityType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentEntitiesGetRequest_Entity, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string entity_ids = 1; */
        for (let i = 0; i < message.entityIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.entityIds[i]);
        /* DocumentModel.DocumentEntityType entity_type = 2; */
        if (message.entityType !== 0)
            writer.tag(2, WireType.Varint).int32(message.entityType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentEntitiesGetRequest.Entity
 */
export const DocumentEntitiesGetRequest_Entity = new DocumentEntitiesGetRequest_Entity$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentEntitiesGetReply$Type extends MessageType<DocumentEntitiesGetReply> {
    constructor() {
        super("DocumentEntitiesGetReply", [
            { no: 1, name: "document_entities", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DocumentEntitiesGetReply_DocumentEntities }
        ]);
    }
    create(value?: PartialMessage<DocumentEntitiesGetReply>): DocumentEntitiesGetReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.documentEntities = [];
        if (value !== undefined)
            reflectionMergePartial<DocumentEntitiesGetReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentEntitiesGetReply): DocumentEntitiesGetReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated DocumentEntitiesGetReply.DocumentEntities document_entities */ 1:
                    message.documentEntities.push(DocumentEntitiesGetReply_DocumentEntities.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentEntitiesGetReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated DocumentEntitiesGetReply.DocumentEntities document_entities = 1; */
        for (let i = 0; i < message.documentEntities.length; i++)
            DocumentEntitiesGetReply_DocumentEntities.internalBinaryWrite(message.documentEntities[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentEntitiesGetReply
 */
export const DocumentEntitiesGetReply = new DocumentEntitiesGetReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentEntitiesGetReply_DocumentEntities$Type extends MessageType<DocumentEntitiesGetReply_DocumentEntities> {
    constructor() {
        super("DocumentEntitiesGetReply.DocumentEntities", [
            { no: 1, name: "entity_type", kind: "enum", T: () => ["DocumentModel.DocumentEntityType", DocumentModel_DocumentEntityType, "DOCUMENT_ENTITY_TYPE_"] },
            { no: 2, name: "entity_documents", kind: "message", T: () => DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID }
        ]);
    }
    create(value?: PartialMessage<DocumentEntitiesGetReply_DocumentEntities>): DocumentEntitiesGetReply_DocumentEntities {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entityType = 0;
        if (value !== undefined)
            reflectionMergePartial<DocumentEntitiesGetReply_DocumentEntities>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentEntitiesGetReply_DocumentEntities): DocumentEntitiesGetReply_DocumentEntities {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* DocumentModel.DocumentEntityType entity_type */ 1:
                    message.entityType = reader.int32();
                    break;
                case /* DocumentEntitiesGetReply.DocumentEntities.TypesByEntityID entity_documents */ 2:
                    message.entityDocuments = DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID.internalBinaryRead(reader, reader.uint32(), options, message.entityDocuments);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentEntitiesGetReply_DocumentEntities, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* DocumentModel.DocumentEntityType entity_type = 1; */
        if (message.entityType !== 0)
            writer.tag(1, WireType.Varint).int32(message.entityType);
        /* DocumentEntitiesGetReply.DocumentEntities.TypesByEntityID entity_documents = 2; */
        if (message.entityDocuments)
            DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID.internalBinaryWrite(message.entityDocuments, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentEntitiesGetReply.DocumentEntities
 */
export const DocumentEntitiesGetReply_DocumentEntities = new DocumentEntitiesGetReply_DocumentEntities$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID$Type extends MessageType<DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID> {
    constructor() {
        super("DocumentEntitiesGetReply.DocumentEntities.TypesByEntityID", [
            { no: 1, name: "by_entity_id", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID_DocumentsByType } }
        ]);
    }
    create(value?: PartialMessage<DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID>): DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.byEntityId = {};
        if (value !== undefined)
            reflectionMergePartial<DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID): DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, DocumentEntitiesGetReply.DocumentEntities.TypesByEntityID.DocumentsByType> by_entity_id */ 1:
                    this.binaryReadMap1(message.byEntityId, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID["byEntityId"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID["byEntityId"] | undefined, val: DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID["byEntityId"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID_DocumentsByType.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field DocumentEntitiesGetReply.DocumentEntities.TypesByEntityID.by_entity_id");
            }
        }
        map[key ?? ""] = val ?? DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID_DocumentsByType.create();
    }
    internalBinaryWrite(message: DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, DocumentEntitiesGetReply.DocumentEntities.TypesByEntityID.DocumentsByType> by_entity_id = 1; */
        for (let k of globalThis.Object.keys(message.byEntityId)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID_DocumentsByType.internalBinaryWrite(message.byEntityId[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentEntitiesGetReply.DocumentEntities.TypesByEntityID
 */
export const DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID = new DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID_DocumentsByType$Type extends MessageType<DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID_DocumentsByType> {
    constructor() {
        super("DocumentEntitiesGetReply.DocumentEntities.TypesByEntityID.DocumentsByType", [
            { no: 1, name: "documents", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => DocumentModel_Document } }
        ]);
    }
    create(value?: PartialMessage<DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID_DocumentsByType>): DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID_DocumentsByType {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.documents = {};
        if (value !== undefined)
            reflectionMergePartial<DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID_DocumentsByType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID_DocumentsByType): DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID_DocumentsByType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, DocumentModel.Document> documents */ 1:
                    this.binaryReadMap1(message.documents, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID_DocumentsByType["documents"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID_DocumentsByType["documents"] | undefined, val: DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID_DocumentsByType["documents"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = DocumentModel_Document.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field DocumentEntitiesGetReply.DocumentEntities.TypesByEntityID.DocumentsByType.documents");
            }
        }
        map[key ?? ""] = val ?? DocumentModel_Document.create();
    }
    internalBinaryWrite(message: DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID_DocumentsByType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, DocumentModel.Document> documents = 1; */
        for (let k of globalThis.Object.keys(message.documents)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            DocumentModel_Document.internalBinaryWrite(message.documents[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentEntitiesGetReply.DocumentEntities.TypesByEntityID.DocumentsByType
 */
export const DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID_DocumentsByType = new DocumentEntitiesGetReply_DocumentEntities_TypesByEntityID_DocumentsByType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentDownloadRequest$Type extends MessageType<DocumentDownloadRequest> {
    constructor() {
        super("DocumentDownloadRequest", [
            { no: 1, name: "document_type_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "entity_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "entity_type", kind: "enum", T: () => ["DocumentModel.DocumentEntityType", DocumentModel_DocumentEntityType, "DOCUMENT_ENTITY_TYPE_"] },
            { no: 4, name: "only_last_versions", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentDownloadRequest>): DocumentDownloadRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.documentTypeIds = [];
        message.entityId = "";
        message.entityType = 0;
        message.onlyLastVersions = false;
        if (value !== undefined)
            reflectionMergePartial<DocumentDownloadRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentDownloadRequest): DocumentDownloadRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string document_type_ids */ 1:
                    message.documentTypeIds.push(reader.string());
                    break;
                case /* string entity_id */ 2:
                    message.entityId = reader.string();
                    break;
                case /* DocumentModel.DocumentEntityType entity_type */ 3:
                    message.entityType = reader.int32();
                    break;
                case /* bool only_last_versions */ 4:
                    message.onlyLastVersions = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentDownloadRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string document_type_ids = 1; */
        for (let i = 0; i < message.documentTypeIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.documentTypeIds[i]);
        /* string entity_id = 2; */
        if (message.entityId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.entityId);
        /* DocumentModel.DocumentEntityType entity_type = 3; */
        if (message.entityType !== 0)
            writer.tag(3, WireType.Varint).int32(message.entityType);
        /* bool only_last_versions = 4; */
        if (message.onlyLastVersions !== false)
            writer.tag(4, WireType.Varint).bool(message.onlyLastVersions);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentDownloadRequest
 */
export const DocumentDownloadRequest = new DocumentDownloadRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentDownloadReply$Type extends MessageType<DocumentDownloadReply> {
    constructor() {
        super("DocumentDownloadReply", [
            { no: 1, name: "file_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentDownloadReply>): DocumentDownloadReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fileId = "";
        if (value !== undefined)
            reflectionMergePartial<DocumentDownloadReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentDownloadReply): DocumentDownloadReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string file_id */ 1:
                    message.fileId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentDownloadReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string file_id = 1; */
        if (message.fileId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.fileId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentDownloadReply
 */
export const DocumentDownloadReply = new DocumentDownloadReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentImageRotateRequest$Type extends MessageType<DocumentImageRotateRequest> {
    constructor() {
        super("DocumentImageRotateRequest", [
            { no: 1, name: "entity_type", kind: "enum", T: () => ["DocumentModel.DocumentEntityType", DocumentModel_DocumentEntityType, "DOCUMENT_ENTITY_TYPE_"] },
            { no: 2, name: "entity_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "document_type_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "degree", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "version_number", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentImageRotateRequest>): DocumentImageRotateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entityType = 0;
        message.entityId = "";
        message.documentTypeId = "";
        message.degree = 0;
        message.versionNumber = 0;
        if (value !== undefined)
            reflectionMergePartial<DocumentImageRotateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentImageRotateRequest): DocumentImageRotateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* DocumentModel.DocumentEntityType entity_type */ 1:
                    message.entityType = reader.int32();
                    break;
                case /* string entity_id */ 2:
                    message.entityId = reader.string();
                    break;
                case /* string document_type_id */ 3:
                    message.documentTypeId = reader.string();
                    break;
                case /* int32 degree */ 4:
                    message.degree = reader.int32();
                    break;
                case /* int64 version_number */ 5:
                    message.versionNumber = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentImageRotateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* DocumentModel.DocumentEntityType entity_type = 1; */
        if (message.entityType !== 0)
            writer.tag(1, WireType.Varint).int32(message.entityType);
        /* string entity_id = 2; */
        if (message.entityId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.entityId);
        /* string document_type_id = 3; */
        if (message.documentTypeId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.documentTypeId);
        /* int32 degree = 4; */
        if (message.degree !== 0)
            writer.tag(4, WireType.Varint).int32(message.degree);
        /* int64 version_number = 5; */
        if (message.versionNumber !== 0)
            writer.tag(5, WireType.Varint).int64(message.versionNumber);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentImageRotateRequest
 */
export const DocumentImageRotateRequest = new DocumentImageRotateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentImageRotateReply$Type extends MessageType<DocumentImageRotateReply> {
    constructor() {
        super("DocumentImageRotateReply", [
            { no: 1, name: "file_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentImageRotateReply>): DocumentImageRotateReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fileId = "";
        if (value !== undefined)
            reflectionMergePartial<DocumentImageRotateReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentImageRotateReply): DocumentImageRotateReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string file_id */ 1:
                    message.fileId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentImageRotateReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string file_id = 1; */
        if (message.fileId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.fileId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentImageRotateReply
 */
export const DocumentImageRotateReply = new DocumentImageRotateReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentVersionDeleteRequest$Type extends MessageType<DocumentVersionDeleteRequest> {
    constructor() {
        super("DocumentVersionDeleteRequest", [
            { no: 1, name: "entity_type", kind: "enum", T: () => ["DocumentModel.DocumentEntityType", DocumentModel_DocumentEntityType, "DOCUMENT_ENTITY_TYPE_"] },
            { no: 2, name: "entity_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "document_type_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "version_number", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentVersionDeleteRequest>): DocumentVersionDeleteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entityType = 0;
        message.entityId = "";
        message.documentTypeId = "";
        message.versionNumber = 0;
        if (value !== undefined)
            reflectionMergePartial<DocumentVersionDeleteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentVersionDeleteRequest): DocumentVersionDeleteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* DocumentModel.DocumentEntityType entity_type */ 1:
                    message.entityType = reader.int32();
                    break;
                case /* string entity_id */ 2:
                    message.entityId = reader.string();
                    break;
                case /* string document_type_id */ 3:
                    message.documentTypeId = reader.string();
                    break;
                case /* int64 version_number */ 4:
                    message.versionNumber = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentVersionDeleteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* DocumentModel.DocumentEntityType entity_type = 1; */
        if (message.entityType !== 0)
            writer.tag(1, WireType.Varint).int32(message.entityType);
        /* string entity_id = 2; */
        if (message.entityId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.entityId);
        /* string document_type_id = 3; */
        if (message.documentTypeId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.documentTypeId);
        /* int64 version_number = 4; */
        if (message.versionNumber !== 0)
            writer.tag(4, WireType.Varint).int64(message.versionNumber);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentVersionDeleteRequest
 */
export const DocumentVersionDeleteRequest = new DocumentVersionDeleteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentVersionDeleteReply$Type extends MessageType<DocumentVersionDeleteReply> {
    constructor() {
        super("DocumentVersionDeleteReply", []);
    }
    create(value?: PartialMessage<DocumentVersionDeleteReply>): DocumentVersionDeleteReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DocumentVersionDeleteReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentVersionDeleteReply): DocumentVersionDeleteReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DocumentVersionDeleteReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentVersionDeleteReply
 */
export const DocumentVersionDeleteReply = new DocumentVersionDeleteReply$Type();
/**
 * @generated ServiceType for protobuf service DocumentsService
 */
export const DocumentsService = new ServiceType("DocumentsService", [
    { name: "DocumentCreate", options: {}, I: DocumentCreateRequest, O: DocumentCreateReply },
    { name: "DocumentUpdate", options: {}, I: DocumentUpdateRequest, O: DocumentUpdateReply },
    { name: "DocumentGet", options: {}, I: DocumentGetRequest, O: DocumentGetReply },
    { name: "DocumentDelete", options: {}, I: DocumentDeleteRequest, O: DocumentDeleteReply },
    { name: "DocumentFileClear", options: {}, I: DocumentFileClearRequest, O: DocumentFileClearReply },
    { name: "DocumentFileUpdate", options: {}, I: DocumentFileUpdateRequest, O: DocumentFileUpdateReply },
    { name: "DocumentGetVersions", options: {}, I: DocumentGetVersionsRequest, O: DocumentGetVersionsReply },
    { name: "DocumentEntitiesGet", options: {}, I: DocumentEntitiesGetRequest, O: DocumentEntitiesGetReply },
    { name: "DocumentDownload", options: {}, I: DocumentDownloadRequest, O: DocumentDownloadReply },
    { name: "DocumentImageRotate", options: {}, I: DocumentImageRotateRequest, O: DocumentImageRotateReply },
    { name: "DocumentVersionDelete", options: {}, I: DocumentVersionDeleteRequest, O: DocumentVersionDeleteReply }
]);
